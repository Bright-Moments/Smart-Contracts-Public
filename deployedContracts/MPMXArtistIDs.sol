//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.19;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {VRFConsumerBase} from "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
contract MPMXArtistIDs is Ownable, VRFConsumerBase
{    
    mapping(uint=>uint) public OrderIndexes;                  // `Index` => `RandomizedOrderIndex` - (Post-Randomized)
    mapping(uint=>uint) public _OrderIndexes;                 // `Index` => `NewOrderIndex` - (Pre-Randomized)
    mapping(uint=>uint) public ArtistID;                      // `TokenID` => `ArtistID` - (Post-Randomized)
    mapping(uint=>uint) public _ArtistID;                     // `Index` => `Initial ChainLink VRF #` - (Pre-Randomized)
    mapping(uint=>string) public ArtistNames;                 // `ArtistID` => `Name (Post-Randomization)`
    mapping(uint=>string) public _ArtistNames;                // `ArtistID` => `Name (Pre-Randomized)`
    mapping(uint=>bool) public _ArtistNameMapped;             // `ArtistID` => `Mapped`
    mapping(uint=>uint) public _ArtistIDNumLimiter;           // `ArtistID` => `Allowance`
    mapping(uint=>bool) public _MintPackStartingIndex;        // `Index` => IsMintPackStartingIndex
    mapping(uint=>bool) public _OrderIndexMapped;             // `OrderIndex` => `Mapped`

    uint public _Status;
    uint public _GeneratedArtistIDs;
    uint public _GeneratedOrderIDs;
    uint public _AttemptedGeneratedOrderIndex;
    uint public _CurrentDrawIndexArtistIDs;
    uint public _CurrentDrawIndexOrderIDs;
    uint public _CurrentDrawIndexArtistNames;
    uint public _CurrentTokenIndexArtistIDs;
    uint public _CurrentTokenIndexOrderIDs;
    uint internal fee;
    uint internal _ArtistMapped;
    uint immutable _fee = 0.0001 ether; 
    uint private immutable _Limit = 75;
    address private immutable _linkToken = 0xb0897686c545045aFc77CF20eC7A532E3120E0F1;       
    address private immutable _vrfCoordinator = 0x3d2341ADb2D31f1c5530cDC622016af293177AE0;     
    bytes32 private immutable _keyHash = 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;
    bytes32 internal keyHash;
    uint[] public _RandomResults;                                                 
    uint[] public _MintPackStartingIndexes;
    
    event RandomArtistIDsSeeded(uint[] ArtistIDs);
    event randomnessFulfilled(bytes32 requestId, uint randomResult);
    event ArtistIDs(uint[] _RandomResults, uint[] expandedResults);
    event ArtistIDsMapped(uint[] _RandomResults, uint[] expandedResults);
    event ArtistNamesSeeded(uint[] Indexes, string[] Names);

    constructor() VRFConsumerBase(_vrfCoordinator, _linkToken) 
    { 
        keyHash = _keyHash;
        fee = _fee;

        // Pre-Randomized Artist Names
        _ArtistNames[0] = "ANNA LUCIA";
        _ArtistNames[1] = "DCA";
        _ArtistNames[2] = "ISKRA VELITCHKOVA";
        _ArtistNames[3] = "MARCELO";
        _ArtistNames[4] = "MONICA RIZZOLLI";
        _ArtistNames[5] = "P1XELFOOL";
        _ArtistNames[6] = "SNOWFRO";
        _ArtistNames[7] = "STEFANO CONTIERO";
        _ArtistNames[8] = "WILLIAM MAPAN";
        _ArtistNames[9] = "ZACH LIEBERMAN";

        // Artist & BM Reservations
        _MintPackStartingIndexes.push(333);
        _MintPackStartingIndexes.push(343);
        _MintPackStartingIndexes.push(353);
        _MintPackStartingIndexes.push(363);
        _MintPackStartingIndexes.push(373);
        _MintPackStartingIndexes.push(383);
        _MintPackStartingIndexes.push(393);
        _MintPackStartingIndexes.push(403);
        _MintPackStartingIndexes.push(413);
        _MintPackStartingIndexes.push(423);
        _MintPackStartingIndexes.push(433);
        _MintPackStartingIndexes.push(443);
        _MintPackStartingIndexes.push(453);
        _MintPackStartingIndexes.push(463);
        _MintPackStartingIndexes.push(473);

        for(uint x; x < _MintPackStartingIndexes.length; x++)
        {
            for(uint y; y < 10; y++) { _MintPackStartingIndex[_MintPackStartingIndexes[x]+y] = true; }
        }
    } 

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/
    
    /**
     * @dev Returns Artist Names
     */
    function ViewAllArtistNames() public view returns (string[] memory)
    {
        string[] memory __ArtistNames = new string[](10);
        for(uint x; x < 10; x++)
        {
            __ArtistNames[x] = ArtistNames[x];
        }
        return __ArtistNames;
    }

    /**
     * @dev Returns An Array Of ArtistIDs Corresponding To Input TokenIDs 
     */
    function ViewArtistIDsByTokenIDs(uint[] calldata TokenIDs) public view returns(uint[] memory)
    {   
        uint[] memory _ArtistIDs = new uint[](TokenIDs.length);
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            _ArtistIDs[TokenID] = ArtistID[TokenIDs[TokenID]];
        }
        return _ArtistIDs;
    }

    /**
     * @dev Returns An Array Of ArtistIDs Corresponding To TokenIDs 0-999
     */
    function ViewAllArtistIDs() public view returns(uint[] memory)
    {
        uint[] memory __ArtistIDs = new uint[](1000);
        for(uint TokenID; TokenID < 1000; TokenID++)
        {
            __ArtistIDs[TokenID] = ArtistID[TokenID];
        }
        return __ArtistIDs;
    }

    /**
     * @dev Returns An Array Of Randomized OrderIDs
     */
    function ViewAllOrderIDs() public view returns(uint[] memory)
    {
        uint[] memory __OrderIDs = new uint[](1000);
        for(uint OrderID; OrderID < __OrderIDs.length; OrderID++)
        {
            __OrderIDs[OrderID] = OrderIndexes[OrderID];
        }
        return __OrderIDs;
    }

    /**
     * @dev Returns A Singular ArtistID
     */
    function ViewArtistID(uint TokenID) public view returns(uint) { return ArtistID[TokenID]; }

    /*----------------
     * VRF FUNCTIONS *
    -----------------*/

    /**
     * @dev Withdraws ERC20 From Contract
     */
    function ____WithdrawERC20(address ERC20) external onlyOwner
    {
        IERC20(ERC20).transferFrom(address(this), msg.sender, IERC20(ERC20).balanceOf(address(this)));
    }

    /**
     * @dev Seeds Mint Pack Starting Indexes In From Mainnet Contract Via The `ViewMintPackStartingIndexes()` Function
     */
    function ____SeedMintPackStartingIndexes(uint[] calldata Indexes) external onlyOwner
    {
        unchecked 
        {
            for(uint x; x < Indexes.length; x++)
            {
                for(uint y; y < 10; y++) { _MintPackStartingIndex[Indexes[x]+y] = true; }
            }
        }
    }

    /**
     * @dev Seeds Order Indexes
     */
    function ____SeedOrderIndexes(uint[] calldata NewOrderIndexes) external onlyOwner
    {
        unchecked {
            for(uint x; x < NewOrderIndexes.length; x++)
            {
                OrderIndexes[x] = NewOrderIndexes[x];
            }
        }
    }

    /**
     * @dev Step 0: Request Random Seed From Chainlink VRF For Order Index Randomization
     */
    function ____VRF0RandomSeedOrderIndexes() external onlyOwner returns (bytes32 requestId)
    {
        require(_Status == 0, "Already Retrieved Random Result For Artist IDs");
        _Status += 1;
        require(LINK.balanceOf(address(this)) >= fee, "LINK: Not enough LINK");
        return requestRandomness(_keyHash, fee);
    }

    /**
     * @dev Step 1: Seeds A Number Of Random OrderIDs Into The Contract Without Duplicates
     */
    function ____VRF1RandomGenerateOrderIDs(uint Index, uint Amount, uint UniqueOrders) external onlyOwner
    {
        unchecked
        {
            uint Range = _AttemptedGeneratedOrderIndex + Amount;
            for(_AttemptedGeneratedOrderIndex; _AttemptedGeneratedOrderIndex < Range; _AttemptedGeneratedOrderIndex++) 
            {
                uint RandomNumber = (uint(keccak256(abi.encode(_RandomResults[Index], _AttemptedGeneratedOrderIndex))) % UniqueOrders);
                if(!_MintPackStartingIndex[RandomNumber]) 
                { 
                    _OrderIndexes[_GeneratedOrderIDs] = RandomNumber; 
                    _GeneratedOrderIDs++;
                }
            }
        }
    }

    /**
     * @dev Step 2: Formats OrderIDs Continually Based On The Randomly Generated OrderIDs
     */
    function ____VRF2FormatOrderIDs(uint Amount) external onlyOwner
    {
        unchecked
        {
            require(_CurrentDrawIndexOrderIDs + Amount <= _GeneratedOrderIDs, "MPMX: Generate More OrderIDs");
            for(uint x; x < Amount; x++)
            {
                // If Current Index Is A Mint Pack Starting Index, Increment The Next TokenID To Be Mapped By 10
                if(_MintPackStartingIndex[_CurrentTokenIndexOrderIDs]) 
                { 
                    for(uint y; y < 10; y++)
                    {
                        OrderIndexes[_CurrentTokenIndexOrderIDs] = _CurrentTokenIndexOrderIDs;
                        _CurrentTokenIndexOrderIDs++; 
                    }
                }

                // If Pre-Randomized ArtistID Is Valid And Has Sufficient Allocation, Use It As The Next ArtistID
                else if(!_OrderIndexMapped[_OrderIndexes[_CurrentDrawIndexOrderIDs]])
                {
                    _OrderIndexMapped[_OrderIndexes[_CurrentDrawIndexOrderIDs]] = true;
                    OrderIndexes[_CurrentTokenIndexOrderIDs] = _OrderIndexes[_CurrentDrawIndexOrderIDs];
                    _CurrentTokenIndexOrderIDs++;
                    _CurrentDrawIndexOrderIDs++;
                }
                
                // Draw A New Random Number Next Loop
                else { _CurrentDrawIndexOrderIDs++; }
            }
        }
    }

    /**
     * @dev Step 3: Request Random Seed From Chainlink VRF
     */
    function ____VRF3RandomSeedArtistIDs() external onlyOwner returns (bytes32 requestId)
    {
        require(LINK.balanceOf(address(this)) >= fee, "LINK: Not enough LINK");
        return requestRandomness(_keyHash, fee);
    }

    /**
     * @dev Step 4: Seeds A Number Of Random ArtistIDs Into The Contract
     * (May Need To Be Run Multiple Times Until All Artist Names Are Seeded)
     */
    function ____VRF4GenerateRandomArtistIDs(uint Index, uint Amount) external onlyOwner
    {
        uint Range = _GeneratedArtistIDs + Amount;
        for(_GeneratedArtistIDs; _GeneratedArtistIDs < Range; _GeneratedArtistIDs++) 
        { 
            _ArtistID[_GeneratedArtistIDs] = (
                uint(keccak256(abi.encode(_RandomResults[Index], _GeneratedArtistIDs))) % 10 // Outputs A Number 0-9 Inclusive
            );
        }
    }

    /**
     * @dev Step 5: Formats ArtistIDs Continually
     */
    function ____VRF5FormatArtistIDs(uint Amount) external onlyOwner
    {
        unchecked
        {
            require(_CurrentDrawIndexArtistIDs + Amount <= _GeneratedArtistIDs, "MPMX: Generate More ArtistIDs");
            for(uint x; x < Amount; x++)
            {
                // If MintPack TokenID, Format TokenIDs Corresponding ArtistID Sequentially
                if(_MintPackStartingIndex[_CurrentTokenIndexArtistIDs])
                {
                    for(uint MintPackArtistID; MintPackArtistID < 10; MintPackArtistID++)
                    {
                        ArtistID[_CurrentTokenIndexArtistIDs] = MintPackArtistID;
                        _CurrentTokenIndexArtistIDs++;
                    }
                }

                // If Pre-Randomized ArtistID Is Valid And Has Sufficient Allocation, Use It As The Next ArtistID
                else if(_ArtistIDNumLimiter[_ArtistID[_CurrentDrawIndexArtistIDs]] < _Limit)
                {
                    _ArtistIDNumLimiter[_ArtistID[_CurrentDrawIndexArtistIDs]]++;
                    ArtistID[OrderIndexes[_CurrentTokenIndexArtistIDs]] = _ArtistID[_CurrentDrawIndexArtistIDs];
                    _CurrentTokenIndexArtistIDs++;
                    _CurrentDrawIndexArtistIDs++;
                }
                
                // Draw A New Random Number Next Loop
                else { _CurrentDrawIndexArtistIDs++; }
            }
        }
    }

    /**
     * @dev Step 6: Request Random Seed From Chainlink VRF
     */
    function ____VRF6RandomSeedArtistNames() external onlyOwner returns (bytes32 requestId)
    {
        require(LINK.balanceOf(address(this)) >= fee, "LINK: Not enough LINK");
        return requestRandomness(_keyHash, fee);
    }

    /**
     * @dev Step 7: Executes Artist Name Mapping
     */
    function ____VRF7ExecuteArtistNameMapping(uint Amount) external onlyOwner
    {
        unchecked
        {
            uint Range = _CurrentDrawIndexArtistNames + Amount;
            for(_CurrentDrawIndexArtistNames; _CurrentDrawIndexArtistNames < Range;)
            {
                uint ArtistIndex = (uint(keccak256(abi.encode(_RandomResults[2], _CurrentDrawIndexArtistNames))) % 10);
                if(!_ArtistNameMapped[ArtistIndex])
                {
                    ArtistNames[_ArtistMapped] = _ArtistNames[ArtistIndex];
                    _ArtistNameMapped[ArtistIndex] = true;
                    _ArtistMapped++;
                }
                _CurrentDrawIndexArtistNames++;
            }
        }
    }

    /**
     * @dev Callback function used by VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint randomness) internal override 
    { 
        _RandomResults.push(randomness);
        emit randomnessFulfilled(requestId, randomness);
    }
}
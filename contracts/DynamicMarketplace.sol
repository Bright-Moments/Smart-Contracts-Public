//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.19;
import { MissionControl } from "./MissionControl.sol";
import { DelegateCashEnabled } from "./DelegateCashEnabled.sol";
import { IMinter } from "./IMinter.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { MerkleProof } from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
contract DynamicMarketplace is MissionControl, DelegateCashEnabled, ReentrancyGuard
{
    struct SaleTypeFixedPrice
    {
        string _Name;                 // [0] -> _Name
        uint _Price;                  // [1] -> _Price
        uint _MintPassProjectID;      // [2] -> _MintPassProjectID
        uint _Type;                   // [3] -> _Type (The Type Of Sale) (Must Be Configured To One Of The Following Options)
                                      // { ----------------------------------------------- }
                                      // |  0 = _MintToFactory() Single Mint               |
                                      // |  1 = _MintToFactory() Mint Pack                 |
                                      // |  2 = purchaseTo() ArtBlocks Direct Sale         |
                                      // |  3 = transferFrom() Already-Minted ERC721 Sale  |
                                      // |  4 = purchaseTo() ArtBlocks Direct Sale /w ETH  |
                                      // { ----------------------------------------------- }
        uint _MinterProjectID;        // [4] -> _MinterProjectID (ArtBlocks or LiveMint)
        uint _AmountForSale;          // [5] -> _AmountForSale
        uint _TimestampStart;         // [6] -> _TimestampStart
        uint _CurrentIndex;           // [7] -> _CurrentIndex
        uint _BatchPurchaseAmount;    // [8] -> _BatchPurchaseAmount (Transfer Amount Per Purchase) (MintPack or Direct Mint)
        address _NFT;                 // [9] -> _NFT
        address _Operator;            // [10] -> _Operator
        bytes32[] _RootEligibilities; // [11] -> _RootEligibilities
        bytes32[] _RootAmounts;       // [12] -> _RootAmounts
    }

    struct FixedPriceSaleInfo
    {
        string _Name;                        // [0] -> _Price
        uint _Price;                         // [1] -> _Price
        uint _MintPassProjectID;             // [2] -> _MintPassProjectID
        uint _Type;                          // [3] -> _Type (The Type Of Sale) (Must Be Configured To One Of These Options)
                                             // { ----------------------------------------------- }
                                             // |  0 = _MintToFactory() Single Mint               |
                                             // |  1 = _MintToFactory() Mint Pack                 |
                                             // |  2 = purchaseTo() ArtBlocks Direct Sale         |
                                             // |  3 = transferFrom() Already-Minted ERC721 Sale  |
                                             // |  4 = purchaseTo() ArtBlocks Direct Sale /w ETH  |
                                             // { ----------------------------------------------- }
        uint _MinterProjectID;               // [4] -> _MinterProjectID (ArtBlocks or LiveMint)
        uint _AmountForSale;                 // [5] -> _AmountForSale
        uint _TimestampStart;                // [6] -> _TimestampStart
        uint _CurrentIndex;                  // [7] -> _CurrentIndex
        uint _BatchPurchaseAmount;           // [8] -> _BatchPurchaseAmount (Transfer Amount Per Purchase)
        address _NFT;                        // [9] -> _NFT
        address _Operator;                   // [10] -> _Operator
        bytes32[] _RootEligibilities;        // [11] -> _RootEligibilities
        bytes32[] _RootAmounts;              // [12] -> _RootAmounts
        uint[] _DiscountAmountWEIValues;     // [14] -> _DiscountAmountWEIValues
        uint _ETHRevenue;                    // [15] -> _ETHRevenue
        uint _AmountRemaining;               // [16] -> _AmountRemaining
        uint _Priority;                      // [17] -> _Priority
        uint _AmountRemainingMerklePriority; // [18] -> _AmountRemainingMerklePriority
        uint _AmountPurchasedUser;           // [19] -> _AmountPurchasedUser
        bool _BrightListEligible;            // [20] -> _BrightListEligible
        bool _BrightListAmounts;             // [21] -> _BrightListAmounts
    }
    
    struct SaleTypePresale 
    {
        string _Name;              // [0] -> _Name
        address _Operator;         // [1] -> _Operator
        address _NFT;              // [2] -> _NFT
        uint _MaxForSale;          // [3] -> _MaxForSale
        uint _MaxPerPurchase;      // [4] -> _MaxPerPurchase
        uint _PricePresale;        // [5] -> _PricePresale
        uint _PricePublic;         // [6] -> _PricePublic
        uint _TimestampEndFullSet; // [7] -> _TimestampEndFullSet
        uint _TimestampEndCitizen; // [8] -> _TimestampEndCitizen
        uint _TimestampSaleStart;  // [9] -> _TimestampSaleStart
        uint _Type;                // [10] -> _Type
        uint _ProjectID;           // [11] -> _ProjectID
    }

    struct InternalPresaleSale
    {
        bool _Active;                 // [0] -> _Active
        uint _AmountSold;             // [1] -> _AmountSold
        uint _ETHRevenue;             // [2] -> _ETHRevenue
        uint _GlobalPurchasesFullSet; // [3] -> _GlobalPurchasesFullSet
        uint _GlobalPurchasesCitizen; // [4] -> _GlobalPurchasesCitizen
        uint _GlobalPurchasesPublic;  // [5] -> _GlobalPurchasesPublic
        uint _CurrentTokenIndex;      // [6] -> _CurrentTokenIndex
        uint _AmountSoldFullSet;      // [7] -> _AmountSoldFullSet
        uint _AmountSoldCitizen;      // [8] -> _AmountSoldCitizen
        uint _AmountSoldPublic;       // [9] -> _AmountSoldPublic
    }

    struct InternalPresaleSaleRoots
    {
        bytes32 _RootEligibilityFullSet; // [0] -> _RootEligibilityFullSet
        bytes32 _RootEligibilityCitizen; // [1] -> _RootEligibilityCitizen
        bytes32 _RootAmountFullSet;      // [2] -> _RootAmountFullSet
        bytes32 _RootAmountCitizen;      // [3] -> _RootAmountCitizen
    }

    struct InternalPresaleWalletInfo    
    {
        uint _AmountPurchasedFullSetWindow; // [0] -> _AmountPurchasedFullSetWindow
        uint _AmountPurchasedCitizenWindow; // [1] -> _AmountPurchasedCitizenWindow
        uint _AmountPurchasedWallet;        // [2] -> _AmountPurchasedWallet
    }

    struct SaleInfoPresale
    {
        uint _ETHRevenue;                   // [0] -> _ETHRevenue
        uint _PricePresale;                 // [1] -> _PricePresale
        uint _PricePublic;                  // [2] -> _PricePublic
        uint _MaxForSale;                   // [3] -> _MaxForSale
        uint _AmountRemaining;              // [4] -> _AmountRemaining
        uint _TimestampEndFullSet;          // [5] -> _TimestampEndFullSet
        uint _TimestampEndCitizen;          // [6] -> _TimestampEndCitizen
        uint _TimestampSaleStart;           // [7] -> _TimestampSaleStart
        uint _AmountPurchasableFullSet;     // [8] -> _AmountPurchasableFullSet
        uint _AmountPurchasableCitizen;     // [9] -> _AmountPurchasableCitizen
        uint _AmountPurchasedFullSetWindow; // [10] -> _AmountPurchasedFullSetWindow
        uint _AmountPurchasedCitizenWindow; // [11] -> _AmountPurchasedCitizenWindow
        uint _GlobalPurchasesFullSet;       // [12] -> _GlobalPurchasesFullSet
        uint _GlobalPurchasesCitizen;       // [13] -> _GlobalPurchasesCitizen
        uint _GlobalPurchasesPublic;        // [14] -> _GlobalPurchasesPublic
        uint _AmountPurchasedWallet;        // [15] -> _AmountPurchasedWallet
        bool _EligibleFullSet;              // [16] -> _EligibleFullSet
        bool _EligibleCitizen;              // [17] -> _EligibleCitizen
        bool _ValidMaxAmountFullSet;        // [18] -> _ValidMaxAmountFullSet
        bool _ValidMaxAmountCitizen;        // [19] -> _ValidMaxAmountCitizen
    }

    /*------------------
     * STATE VARIABLES *
    -------------------*/

    uint public _TOTAL_UNIQUE_PRESALE_SALES;                                             // Total Unique Presale Sales                
    uint public _TOTAL_UNIQUE_FIXED_SALES;                                               // Total Unique Fixed Price Sales
    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`a
    
    /*-----------
     * MAPPINGS *
    ------------*/

    mapping(uint=>SaleTypeFixedPrice) public FixedPriceSales;                                 // [SaleIndex] -> SaleTypeFixedPrice
    mapping(uint=>SaleTypePresale) public PresaleSales;                                       // [SaleIndex] -> SaleTypePresale
    mapping(uint=>InternalPresaleSale) public PresaleSalesInternal;                           // [SaleIndex] -> InternalPresaleSale
    mapping(uint=>uint) public AmountSoldFixedPrice;                                          // [SaleIndex] -> Amount Sold
    mapping(uint=>uint[]) public DiscountAmounts;                                             // [SaleIndex] -> Discount Amounts
    mapping(uint=>InternalPresaleSaleRoots) public InternalRoots;                             // [SaleIndex] -> InternalPresaleSaleRoots
    mapping(uint=>mapping(address=>InternalPresaleWalletInfo)) public InternalSaleWalletInfo; // [SaleIndex][Wallet] -> InternalPresaleWalletInfo
    mapping(uint=>uint) public ETHRevenueFixedPriceSale;                                      // [SaleIndex] -> ETH Amount
    mapping(uint=>uint) public ETHRevenueWithdrawn;                                           // [SaleIndex] -> ETH Amount Withdrawn
    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount;       // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level
    mapping(address=>bool) public Admin;                                                      // [Address] -> Admin Status
    mapping(uint=>mapping(address=>uint)) public UserPurchasedAmount;                         // [SaleIndex][Wallet] -> Purchased Amount

    /*---------
     * EVENTS *
    ----------*/

    /**
     * @dev Emitted When A Presale Sale Is Purchased
     * @param SaleIndex The Sale Index
     * @param Purchaser The Purchaser Address
     * @param DesiredAmount The Desired Amount To Purchase
     * @param MessageValue The Amount Sent With The Transaction
     * @param PresaleEnded Whether The Presale Has Ended
     */
    event PurchasedPresale(uint SaleIndex, address Purchaser, uint DesiredAmount, uint MessageValue, bool PresaleEnded);    

    /**
     * @dev Emitted When A Fixed Price Sale Is Purchased
     * @param SaleIndex The Sale Index
     */
    event SaleStarted(uint SaleIndex);

    /**
     * @dev Emitted When A Fixed Price Sale Is Refunded
     * @param Refundee The Address Being Refunded
     * @param Amount The Amount Being Refunded
     */
    event Refunded(address Refundee, uint Amount);

    /**
     * @dev Emitted When A Fixed Price Sale Is Purchased
     * @param SaleIndex The Sale Index
     * @param Purchaser The Purchaser Address
     * @param Amount The Amount Purchased
     * @param Priority The Priority Level
     */
    event Purchased(uint SaleIndex, address Purchaser, uint Amount, uint Priority);

    /**
     * @dev Full Set Purchase
     */
    event Fullset();

    /**
     * @dev Citizen Purchase
     */
    event Citizen();

    /**
     * @dev Public Purchase
     */
    event Public();

    /*---------------------
     * EXTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Purchases One Fixed Price Sale
     * @param SaleIndex The Sale Index To Purchase
     * @param DesiredAmount The Desired Amount To Purchase
     * @param MaxAmount The Maximum Merkle Priority To Purchase
     * @param Vault Delegate Vault Address
     * @param ProofEligibility Merkle Proof For Eligibility
     * @param ProofAmount Merkle Proof For MaxAmount
     */
    function PurchaseFixedPrice (
        uint SaleIndex,
        uint DesiredAmount,
        uint MaxAmount,
        address Vault,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) external payable nonReentrant {
        require(tx.origin == msg.sender, "Marketplace: EOA Only");
        __FinalizeFixedPriceSale(
            SaleIndex, 
            DesiredAmount, 
            MaxAmount, 
            Vault, 
            ProofEligibility, 
            ProofAmount, 
            msg.value,
            msg.sender
        );
    }

    /**
     * @dev Purchases One Fixed Price Sale To A Specific Address
     * @param SaleIndex The Sale Index To Purchase
     * @param DesiredAmount The Desired Amount To Purchase
     * @param MaxAmount The Maximum Merkle Priority To Purchase
     * @param Vault Delegate Vault Address
     * @param Recipient The Address To Receive The NFT
     * @param ProofEligibility Merkle Proof For Eligibility
     * @param ProofAmount Merkle Proof For MaxAmount
     */
    function PurchaseFixedPriceTo (
        uint SaleIndex,
        uint DesiredAmount,
        uint MaxAmount,
        address Vault,
        address Recipient,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) external payable nonReentrant {
        require(tx.origin == msg.sender, "Marketplace: EOA Only");
        __FinalizeFixedPriceSale(
            SaleIndex, 
            DesiredAmount, 
            MaxAmount, 
            Vault, 
            ProofEligibility, 
            ProofAmount, 
            msg.value,
            Recipient
        );
    }

    /**
     * @dev Purchases Multiple Fixed Price Sales
     * @param SaleIndexes The Sale Indexes To Purchase
     * @param DesiredAmounts The Desired Amounts To Purchase
     * @param MaxAmounts The Maximum Merkle Priority To Purchase
     * @param Vaults Delegate Vault Addresses
     * @param ProofEligibilities Merkle Proofs For Eligibility
     * @param ProofAmounts Merkle Proofs For MaxAmount
     * @param MessageValues The Amounts To Purchase Per Sale
     */
    function PurchaseFixedPriceMulti (
        uint[] calldata SaleIndexes,
        uint[] calldata DesiredAmounts,
        uint[] calldata MaxAmounts,
        address[] calldata Vaults,
        bytes32[][] calldata ProofEligibilities,
        bytes32[][] calldata ProofAmounts,
        uint[] calldata MessageValues
    ) external payable nonReentrant {
        require(tx.origin == msg.sender, "Marketplace: EOA Only");
        require(
            SaleIndexes.length == DesiredAmounts.length 
            &&
            DesiredAmounts.length == MaxAmounts.length
            &&
            MaxAmounts.length == Vaults.length
            &&
            Vaults.length == ProofEligibilities.length
            &&
            ProofEligibilities.length == ProofAmounts.length
            && 
            ProofAmounts.length == MessageValues.length,
            "Marketplace: Incorrect Array Lengths"
        );
        uint MessageValueSum;
        for(uint x; x < SaleIndexes.length; x++)
        {
            __FinalizeFixedPriceSale(
                SaleIndexes[x], 
                DesiredAmounts[x], 
                MaxAmounts[x], 
                Vaults[x], 
                ProofEligibilities[x], 
                ProofAmounts[x],
                MessageValues[x],
                msg.sender
            );
            MessageValueSum += MessageValues[x];
        }
        require(MessageValueSum == msg.value, "Marketplace: `msg.value` & `MessageValues` Input Incorrect");
    }

    /**
     * @dev Presale Purchase
     * @param SaleIndex The Sale Index To Purchase
     * @param DesiredAmount The Desired Amount To Purchase
     * @param MaxAmount The Maximum Amount For Merkle Priority Purchase
     * @param Vault Delegate Vault Address
     * @param ProofEligibility Merkle Proof For Eligibility
     * @param ProofAmount Merkle Proof For MaxAmount
     */
    function PurchasePresale (
        uint SaleIndex,                      
        uint DesiredAmount,                  
        uint MaxAmount,                      
        address Vault,                       
        bytes32[] calldata ProofEligibility, 
        bytes32[] calldata ProofAmount 
    ) external payable nonReentrant {
        __FinalizePresale(
            SaleIndex, 
            DesiredAmount, 
            MaxAmount, 
            Vault, 
            ProofEligibility, 
            ProofAmount,
            msg.value,
            msg.sender
        );
    }

    /*---------------------
     * OPERATOR FUNCTIONS *
    ----------------------*/

    /**
     * @dev Instantiates A New Presale Sale
     * @param _Sale The Presale Sale Struct
     * @param _Roots The Presale Sale Roots Struct
     * @return SaleIndex The Sale Index
     */
    function _StartPresaleSale(SaleTypePresale memory _Sale, InternalPresaleSaleRoots memory _Roots) external onlyOperator returns (uint SaleIndex)
    {
        SaleIndex = _TOTAL_UNIQUE_PRESALE_SALES;
        PresaleSales[SaleIndex] = _Sale; 
        PresaleSalesInternal[SaleIndex]._Active = true;
        InternalRoots[SaleIndex] = _Roots;
        emit SaleStarted(SaleIndex);
        _TOTAL_UNIQUE_PRESALE_SALES = SaleIndex + 1;
        return SaleIndex;
    }

    /**
     * @dev Initializes A Sale Via A Struct
     * @param _Sale The Sale Struct
     * @param _Discounts The Array Of Discount Amounts ([80,90] = [20%,10%]) Discounts
     * @return SaleIndex The Sale Index
     */
    function _StartFixedPriceSale (
        SaleTypeFixedPrice memory _Sale, 
        uint[] calldata _Discounts
    ) external onlyOperator returns (uint SaleIndex) { return __FixedPriceSaleInit(_Sale, _Discounts); }

    /**
     * @dev Changes The Presale Sale Type
     * @param _SaleIndex The Sale Index To Edit
     * @param Type The Sale Type (0 = _MintToFactory() | 1 = purchaseTo() | 2 = transferFrom())
     */
    function _ChangePresaleType(uint _SaleIndex, uint Type) external onlyOperator
    {
        PresaleSales[_SaleIndex]._Type = Type;
    }

    /**
     * @dev Changes Presale ArtBlocks ProjectID
     * @param SaleIndex The Sale Index To Edit
     * @param ProjectID ArtBlocks ProjectID
     */
    function _ChangePresaleProjectID(uint SaleIndex, uint ProjectID) external onlyOperator
    {
        PresaleSales[SaleIndex]._ProjectID = ProjectID;
    }

    /**
     * @dev Changes All Presale Roots
     * @param SaleIndex The Sale Index To Edit
     * @param RootEligibilityFullSet The Merkle Eligibility Root For Full Set
     * @param RootAmountsFullSet The Merkle Amounts Root For Full Set
     * @param RootEligibilityCitizen The Merkle Eligibility Root For Citizens
     * @param RootAmountsCitizen The Merkle Amounts Root For Citizens
     */
    function _ChangePresaleRoots (
        uint SaleIndex,
        bytes32 RootEligibilityFullSet,
        bytes32 RootAmountsFullSet,
        bytes32 RootEligibilityCitizen,
        bytes32 RootAmountsCitizen
    ) external onlyOperator { 
        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootEligibilityFullSet;
        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootEligibilityCitizen;
        InternalRoots[SaleIndex]._RootAmountFullSet = RootAmountsFullSet;
        InternalRoots[SaleIndex]._RootAmountCitizen = RootAmountsCitizen;
    }

    /**
     * @dev Changes Presale Sale Max For Sale
     * @param SaleIndex The Sale Index To Edit
     * @param MaxForSale The Total Amount For Sale
     */
    function _ChangePresaleSaleMaxForSale(uint SaleIndex, uint MaxForSale) external onlyOperator 
    {   
        require(PresaleSalesInternal[SaleIndex]._Active, "Marketplace: Sale Not Active");
        PresaleSales[SaleIndex]._MaxForSale = MaxForSale; 
    }

    /**
     * @dev Change Presale Sale Max Per Purchase
     * @param SaleIndex The Sale Index To Edit
     * @param MaxPerPurchase The Maximum Purchase Amount Per Transaction
     */
    function _ChangePresaleSaleMaxPerPurchase(uint SaleIndex, uint MaxPerPurchase) external onlyOperator 
    {   
        require(PresaleSalesInternal[SaleIndex]._Active, "Marketplace: Sale Not Active");
        PresaleSales[SaleIndex]._MaxPerPurchase = MaxPerPurchase; 
    }

    /**
     * @dev Changes Presale Sale Prices
     * @param SaleIndex The Sale Index To Edit
     * @param PricePresale The Price For Presale
     * @param PricePublic The Price For Public
     */
    function _ChangePresalePrices(uint SaleIndex, uint PricePresale, uint PricePublic) external onlyOperator 
    {   
        require(PresaleSalesInternal[SaleIndex]._Active, "Marketplace: Sale Not Active");
        PresaleSales[SaleIndex]._PricePresale = PricePresale; 
        PresaleSales[SaleIndex]._PricePublic = PricePublic; 
    }

    /**
     * @dev Changes Presale Sale Operator
     * @param SaleIndex The Sale Index To Edit
     * @param TimestampSaleStart The Unix Timestamp For Sale Start
     * @param TimestampFullSet The Unix Timestamp When Full Set Window Ends
     * @param TimestampCitizen The Unix Timestamp When Citizen Window Ends (Public Begins)
     */
    function _ChangePresaleTimes(uint SaleIndex, uint TimestampSaleStart, uint TimestampFullSet, uint TimestampCitizen) external onlyOperator
    {
        require(PresaleSalesInternal[SaleIndex]._Active, "Marketplace: Sale Not Active");
        PresaleSales[SaleIndex]._TimestampSaleStart = TimestampSaleStart;
        PresaleSales[SaleIndex]._TimestampEndFullSet = TimestampFullSet;
        PresaleSales[SaleIndex]._TimestampEndCitizen = TimestampCitizen;
    }

    /**
     * @dev Changes The Price Of A Fixed Price Sale
     * @param SaleIndex The Sale Index To Edit
     * @param Price The Sale Price (IN WEI)
     */
    function _ChangeFixedPrice(uint SaleIndex, uint Price) external onlyOperator { FixedPriceSales[SaleIndex]._Price = Price; }

    /**
     * @dev Changes The MintPass ProjectID
     * @param SaleIndex The Sale Index To Edit
     * @param MintPassProjectID The Mint Pass ProjectID
     */
    function _ChangeFixedPriceMintPassProjectID(uint SaleIndex, uint MintPassProjectID) external onlyOperator 
    { 
        FixedPriceSales[SaleIndex]._MintPassProjectID = MintPassProjectID; 
    }

    /**
     * @dev Changes The Type Of A Sale
     * @param SaleIndex The Sale Index To Edit
     * @param Type The Sale Type (0 = _MintToFactory() | 1 = purchaseTo() | 2 = transferFrom())
     */
    function _ChangeFixedPriceType(uint SaleIndex, uint Type) external onlyOperator { FixedPriceSales[SaleIndex]._Type = Type; }

    /**
     * @dev Changes The ArtBlocks ProjectID
     * @param SaleIndex The Sale Index To Edit
     * @param ABProjectID ArtBlocks ProjectID
     */
    function _ChangeFixedPriceABProjectID(uint SaleIndex, uint ABProjectID) external onlyOperator { FixedPriceSales[SaleIndex]._MinterProjectID = ABProjectID; }

    /**
     * @dev Changes The Amount Of NFTs For Sale
     * @param SaleIndex The Sale Index To Edit
     * @param AmountForSale The Total Amount For Sale
     */
    function _ChangeFixedPriceAmountForSale(uint SaleIndex, uint AmountForSale) external onlyOperator { FixedPriceSales[SaleIndex]._AmountForSale = AmountForSale; }

    /**
     * @dev Changes A Fixed Price Sale's Unix Start Time
     * @param SaleIndex The Sale Index To Edit
     * @param UnixTimestamp The Unix Timestamp To Store
     */
    function _ChangeFixedPriceStartTimestamp(uint SaleIndex, uint UnixTimestamp) external onlyOperator { FixedPriceSales[SaleIndex]._TimestampStart = UnixTimestamp; }
   
   /**
     * @dev Changes A Fixed Price Sale's Unix Start Time
     * @param SaleIndex The Sale Index To Edit
     * @param CurrentIndex The Current TokenID To Disperse
     */
    function _ChangeFixedPriceCurrentIndex(uint SaleIndex, uint CurrentIndex) external onlyOperator { FixedPriceSales[SaleIndex]._CurrentIndex = CurrentIndex; }

    /**
     * @dev Changes The NFT Address Of A Fixed Price Sale
     * @param SaleIndex The Sale Index To Edit
     * @param NewAddress The NFT Contract Address To Store
     */
    function _ChangeFixedPriceNFTAddress(uint SaleIndex, address NewAddress) external onlyOperator { FixedPriceSales[SaleIndex]._NFT = NewAddress; }

    /**
     * @dev Changes The NFT Address Of A Fixed Price Sale
     * @param SaleIndex The Sale Index To Edit
     * @param Operator The Operator Holding The NFTs To Disperse
     */
    function _ChangeFixedPriceOperator(uint SaleIndex, address Operator) external onlyOperator { FixedPriceSales[SaleIndex]._Operator = Operator; }

    /**
     * @dev Changes The Fixed Price Merkle Root For Merkle Eligibility
     * @param SaleIndex The Sale Index To Edit
     * @param NewRoots The Merkle Roots To Store
     */
    function _ChangeFixedPriceRootEligibility(uint SaleIndex, bytes32[] calldata NewRoots) external onlyOperator { FixedPriceSales[SaleIndex]._RootEligibilities = NewRoots; }

    /**
     * @dev Changes The Fixed Price Merkle Root For Merkle Eligibility
     * @param SaleIndex The Sale Index To Edit
     * @param NewRoots The Merkle Root To Store
     */
    function _ChangeFixedPriceRootAmounts(uint SaleIndex, bytes32[] calldata NewRoots) external onlyOperator { FixedPriceSales[SaleIndex]._RootAmounts = NewRoots; }

    /**
     * @dev Changes The Fixed Price Sale Roots
     * @param SaleIndex The Sale Index To Edit
     * @param RootEligibilities The Merkle Root For Merkle Eligibility
     * @param RootAmounts The Merkle Root For Amounts
     */
    function _ChangeFixedPriceSaleRoots(uint SaleIndex, bytes32[] calldata RootEligibilities, bytes32[] calldata RootAmounts) external onlyOperator
    {
        FixedPriceSales[SaleIndex]._RootEligibilities = RootEligibilities;
        FixedPriceSales[SaleIndex]._RootAmounts = RootAmounts;
    }

    /**
     * @dev Changes Fixed Price Sale Discount Amounts (IN BIPS)
     * @param SaleIndex The Sale Index To Edit
     * @param Discounts The Array Of Discount Amounts ([80,90] = 20%, 10% Discount) To Seed
     */
    function _ChangeFixedPriceDiscountAmounts(uint SaleIndex, uint[] calldata Discounts) external onlyOperator
    {
        for(uint x; x < Discounts.length; x++) { require(Discounts[x] <= 100, "Marketplace: Invalid Discount Amounts");}
        DiscountAmounts[SaleIndex] = Discounts;
    }

    /**
     * @dev Changes The Fixed Price Sale Mint Pack Amount
     * @param SaleIndex The Sale Index To Edit
     * @param MintPackAmount The Mint Pack Amount To Seed
     */
    function _ChangeFixedPriceMintPackAmount(uint SaleIndex, uint MintPackAmount) external onlyOperator
    {
        FixedPriceSales[SaleIndex]._BatchPurchaseAmount = MintPackAmount;
    }

    /**
     * @dev Sweeps Proceeds From A Sale Index To Multisig
     * @param SaleIndex The Sale Index To Withdraw From
     */
    function _WithdrawETHFromSaleIndexToMultisig(uint SaleIndex) external onlyOperator
    {
        require(ETHRevenueFixedPriceSale[SaleIndex] - ETHRevenueWithdrawn[SaleIndex] > 0, "Marketplace: No ETH To Withdraw");
        uint WithdrawAmount = ETHRevenueFixedPriceSale[SaleIndex] - ETHRevenueWithdrawn[SaleIndex];
        ETHRevenueWithdrawn[SaleIndex] += WithdrawAmount;
        (bool success,) = _BRT_MULTISIG.call { value: WithdrawAmount }(""); 
        require(success, "Marketplace: ETH Withdraw Failed"); 
    }

    /**
     * @dev Withdraws ETH In Contract To Multisig
     */
    function _WithdrawAllETHToMultisig() external onlyOperator 
    {
        (bool success,) = _BRT_MULTISIG.call { value: address(this).balance }(""); 
        require(success, "Marketplace: ETH Withdraw Failed"); 
    }

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/

    /**
     * @dev Returns The Fixed Price Merkle Roots
     * @param SaleIndex The Sale Index To View
     * @return _RootEligibilities The Merkle Root For Eligibility
     * @return _RootAmounts The Merkle Root For Amounts
     */
    function ViewFixedPriceRoots(uint SaleIndex) external view returns (bytes32[] memory, bytes32[] memory)
    {
        return (FixedPriceSales[SaleIndex]._RootEligibilities, FixedPriceSales[SaleIndex]._RootAmounts);
    }

    /**
     * @dev Verifies BrightList For Presale
     * @param _Wallet The Wallet To Verify
     * @param _RootEligibilities The Merkle Root For Eligibility
     * @param _Proof The Merkle Proof For Eligibility
     */
    function VerifyBrightList(address _Wallet, bytes32 _RootEligibilities, bytes32[] calldata _Proof) public pure returns(bool)
    {
        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));
        return MerkleProof.verify(_Proof, _RootEligibilities, _Leaf);
    }

    /**
     * @dev Verifies BrightList For Presale Fixed Price Sale
     * @param SaleIndex The Sale Index To Verify
     * @param _Wallet The Wallet To Verify
     * @param _ProofEligibility The Merkle Proof For Eligibility
     */
    function VerifyBrightListWithPriority (
        uint SaleIndex, 
        address _Wallet, 
        bytes32[] calldata _ProofEligibility
    ) public view returns (bool, uint) {
        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));
        for(uint x; x < DiscountAmounts[SaleIndex].length; x++) 
        { 
            if(MerkleProof.verify(_ProofEligibility, FixedPriceSales[SaleIndex]._RootEligibilities[x], _Leaf)) { return (true, x); } 
        }
        return (false, 69420);
    }

    /**
     * @dev Verifies Merkle Amount Is Passed Correctly
     * @param _Wallet The Wallet To Verify
     * @param _Amount The Amount To Verify
     * @param _RootAmounts The Merkle Root For Amounts
     * @param _ProofAmount The Merkle Proof For Amounts
     * @return bool Whether The Amount Is Valid
     */
    function VerifyBrightListAmount (
        address _Wallet,
        uint _Amount,
        bytes32 _RootAmounts,
        bytes32[] calldata _ProofAmount
    ) public pure returns (bool) {
        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));
        return MerkleProof.verify(_ProofAmount, _RootAmounts, _Leaf);
    }

    /**
     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid
     * @param _Wallet The Wallet To Verify
     * @param _Amount The Amount To Verify
     * @param _RootEligibilities The Merkle Root For Amounts
     * @param _ProofEligibility The Merkle Proof For Amounts
     * @return bool Whether The Amount Is Valid
     */
    function VerifyAmount(address _Wallet, uint _Amount, bytes32 _RootEligibilities, bytes32[] calldata _ProofEligibility) public pure returns (bool)
    {
        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));
        return MerkleProof.verify(_ProofEligibility, _RootEligibilities, _Leaf);
    }

    /**
     * @dev Returns Information Of A Fixed Price Sale
     * @param SaleIndex The Sale Index To View
     * @param Wallet The Wallet To View
     * @param MaxAmount The Maximum Amount To View
     * @param ProofEligibility The Merkle Proof For Eligibility
     * @param ProofAmount The Merkle Proof For Amount
     */
    function ViewSaleInfoFixedPrice (
        uint SaleIndex,
        address Wallet,
        uint MaxAmount,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) public view returns (FixedPriceSaleInfo memory) {
        return __ViewSaleInfoFixedPrice(
            SaleIndex,
            Wallet,
            MaxAmount,
            ProofEligibility,
            ProofAmount
        );
    }

    /**
     * @dev Returns Information Of Multiple Fixed Price Sales
     * @param SaleIndexes The Sale Indexes To View
     * @param Wallets The Wallets To View
     * @param MaxAmounts The Maximum Amounts To View
     * @param ProofEligibilities The Merkle Proofs For Eligibility
     * @param ProofAmounts The Merkle Proofs For Amount
     * @return _Sales The Sale Information
     */
    function ViewSaleInfosFixedPrice(
        uint[] calldata SaleIndexes,
        address[] calldata Wallets,
        uint[] calldata MaxAmounts,
        bytes32[][] calldata ProofEligibilities,
        bytes32[][] calldata ProofAmounts
    ) public view returns (FixedPriceSaleInfo[] memory _Sales)
    {
        _Sales = new FixedPriceSaleInfo[](SaleIndexes.length);
        for(uint x; x < SaleIndexes.length; x++)
        {
            _Sales[x] = __ViewSaleInfoFixedPrice(
                SaleIndexes[x],
                Wallets[x],
                MaxAmounts[x],
                ProofEligibilities[x],
                ProofAmounts[x]
            );
        }
        return _Sales;
    }
    
    /**
     * @dev Returns A Wallet's Sale Information For A Presale Sale
     * @param SaleIndex The Sale Index To View
     * @param Wallet The Wallet To View
     * @param MaxAmountFullSet The Maximum Amount For Full Set
     * @param MaxAmountCitizen The Maximum Amount For Citizen
     * @param FullsetProof The Merkle Proof For Full Set
     * @param CitizenProof The Merkle Proof For Citizen
     * @param ProofAmountFullSet The Merkle Proof For Max Amount Full Set
     * @param ProofAmountCitizen The Merkle Proof For Max Amount Citizen
     * @return SaleInfoPresale The Sale Information
     */
    function ViewSaleInfoPresale (
        uint SaleIndex,
        address Wallet,
        uint MaxAmountFullSet,
        uint MaxAmountCitizen,
        bytes32[] calldata FullsetProof, 
        bytes32[] calldata CitizenProof,
        bytes32[] calldata ProofAmountFullSet,
        bytes32[] calldata ProofAmountCitizen
    ) public view returns (SaleInfoPresale memory) {
        uint AmountPurchaseableFullset;
        uint AmountPurchaseableCitizen;
        SaleTypePresale memory _Sale = PresaleSales[SaleIndex];
        InternalPresaleSale memory _SaleInternal = PresaleSalesInternal[SaleIndex];
        InternalPresaleWalletInfo memory _WalletInfo = InternalSaleWalletInfo[SaleIndex][Wallet];
        uint AmountRemaining = _Sale._MaxForSale - _SaleInternal._AmountSold;
        uint ETHRevenue = _SaleInternal._ETHRevenue;
        if(_WalletInfo._AmountPurchasedFullSetWindow >= MaxAmountFullSet) { AmountPurchaseableFullset = 0; }
        else { AmountPurchaseableFullset = MaxAmountFullSet - _WalletInfo._AmountPurchasedFullSetWindow; }
        if(_WalletInfo._AmountPurchasedCitizenWindow >= MaxAmountCitizen) { AmountPurchaseableCitizen = 0; }
        else { AmountPurchaseableCitizen = MaxAmountCitizen - _WalletInfo._AmountPurchasedCitizenWindow; }
        return SaleInfoPresale (
            ETHRevenue, // ETHRevenue
            _Sale._PricePresale, // _PricePresale
            _Sale._PricePublic, // _PricePublic
            _Sale._MaxForSale, // _MintPassesAvailable
            AmountRemaining, // _AmountRemaining
            _Sale._TimestampEndFullSet, // _TimestampEndFullSet
            _Sale._TimestampEndCitizen, // _TimestampEndCitizen
            _Sale._TimestampSaleStart, // _TimestampSaleStart
            AmountPurchaseableFullset, // _AmountPurchasableFullSet
            AmountPurchaseableCitizen, // _AmountPurchasableCitizen
            _WalletInfo._AmountPurchasedFullSetWindow, // _AmountPurchasedFullSetWindow
            _WalletInfo._AmountPurchasedCitizenWindow, // _AmountPurchasedCitizenWindow
            _SaleInternal._GlobalPurchasesFullSet, // _GlobalPurchasesFullSet
            _SaleInternal._GlobalPurchasesCitizen, // _GlobalPurchasesCitizen
            _SaleInternal._GlobalPurchasesPublic, // _GlobalPurchasesPublic
            _WalletInfo._AmountPurchasedWallet, // _AmountPurchasedWallet
            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityFullSet, FullsetProof), // _EligibleFullSet
            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityCitizen, CitizenProof), // _EligibleCitizen
            VerifyAmount(Wallet, MaxAmountFullSet, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmountFullSet), // _ValidMaxAmountFullSet
            VerifyAmount(Wallet, MaxAmountCitizen, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmountCitizen) // _ValidMaxAmountCitizen
        );
    }

    /**
     * @dev Initializes A Sale Via A Struct
     * @param _Sale The Sale Struct
     * @param _Discounts The Array Of Discount Amounts ([80,90] = [20%,10%]) Discounts
     */
    function __FixedPriceSaleInit(SaleTypeFixedPrice memory _Sale, uint[] calldata _Discounts) internal returns (uint SaleIndex) 
    { 
        require(
            _Sale._RootEligibilities.length == _Sale._RootAmounts.length
            &&
            _Sale._RootAmounts.length == _Discounts.length,
            "Marketplace: All Array Lengths Must Match"
        );
        for(uint x; x < _Discounts.length; x++) { require(_Discounts[x] <= 100 && _Discounts[x] > 0, "Marketplace: Discount Amounts Must Be <= 100 & > 0"); }
        SaleIndex = _TOTAL_UNIQUE_FIXED_SALES;
        FixedPriceSales[SaleIndex] = _Sale; 
        DiscountAmounts[SaleIndex] = _Discounts;
        _TOTAL_UNIQUE_FIXED_SALES = SaleIndex + 1;
        emit SaleStarted(SaleIndex);
        return SaleIndex;
    }

    /**
     * @dev Finalizes A Fixed Price Sale
     * @param SaleIndex The Sale Index To Purchase
     * @param DesiredAmount The Desired Amount To Purchase
     * @param MaxAmount The Maximum Amount For Merkle Priority Purchase
     * @param Vault Delegate Vault Address
     * @param ProofEligibility Merkle Proof For Eligibility
     * @param ProofAmount Merkle Proof For MaxAmount
     * @param MessageValue The Amount Sent With The Transaction
     * @param Purchaser The Purchaser Address
     */
    function __FinalizeFixedPriceSale(
        uint SaleIndex,
        uint DesiredAmount,
        uint MaxAmount,
        address Vault,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount,
        uint MessageValue,
        address Purchaser
    ) internal {
        address MerkleRecipient = Purchaser;
        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(Purchaser, Vault)) { MerkleRecipient = Vault; } }
        require(block.timestamp >= FixedPriceSales[SaleIndex]._TimestampStart, "Marketplace: Sale Not Started");
        (bool BrightList, uint Priority) = VerifyBrightListWithPriority(SaleIndex, MerkleRecipient, ProofEligibility);
        if(BrightList)  
        {
            require(
                VerifyBrightListAmount( 
                    MerkleRecipient, 
                    MaxAmount, 
                    FixedPriceSales[SaleIndex]._RootAmounts[Priority], 
                    ProofAmount
                ), 
                "DutchMarketplace: Invalid Max Amount Merkle Proof For Provided Merkle Priority"
            );
            require(
                MessageValue
                == 
                (((FixedPriceSales[SaleIndex]._Price * DesiredAmount) * DiscountAmounts[SaleIndex][Priority]) / 100), 
                "Marketplace: Incorrect BrightList ETH Sent"
            );
            require(
                DesiredAmount + PriorityPurchaseAmount[SaleIndex][MerkleRecipient][Priority] 
                <= 
                MaxAmount, 
                "Marketplace: Desired Purchase Amount Exceeds Purchase Allocation"
            );
            PriorityPurchaseAmount[SaleIndex][MerkleRecipient][Priority] += DesiredAmount;
        }
        else { require(MessageValue == FixedPriceSales[SaleIndex]._Price * DesiredAmount, "Marketplace: Incorrect ETH Amount Sent"); }
        require(AmountSoldFixedPrice[SaleIndex] + DesiredAmount <= FixedPriceSales[SaleIndex]._AmountForSale, "Marketplace: Not Enough NFTs Left For Sale");
        AmountSoldFixedPrice[SaleIndex] = AmountSoldFixedPrice[SaleIndex] + DesiredAmount;
        if(FixedPriceSales[SaleIndex]._Type == 0) // Factory MintPass Direct Mint
        { 
            IMinter(FixedPriceSales[SaleIndex]._NFT)._MintToFactory(
                Purchaser, 
                DesiredAmount
            ); 
        }
        else if (FixedPriceSales[SaleIndex]._Type == 1) // Factory MintPass MintPack Direct Mint
        {
            for(uint x; x < DesiredAmount; x++)
            {
                IMinter(FixedPriceSales[SaleIndex]._NFT)._MintToFactory(
                    Purchaser, 
                    FixedPriceSales[SaleIndex]._BatchPurchaseAmount
                ); 
            }
        }
        else if(FixedPriceSales[SaleIndex]._Type == 2) // ArtBlocks purchaseTo() Mint
        { 
            uint ProjectID = FixedPriceSales[SaleIndex]._MinterProjectID;
            for(uint x; x < DesiredAmount; x++) { IMinter(FixedPriceSales[SaleIndex]._NFT).purchaseTo(Purchaser, ProjectID); }
        } 
        else if (FixedPriceSales[SaleIndex]._Type == 3) // ERC721 transferFrom() Sale
        {
            IERC721 _NFT = IERC721(FixedPriceSales[SaleIndex]._NFT);
            address _Operator = FixedPriceSales[SaleIndex]._Operator;
            uint _StartingIndex = FixedPriceSales[SaleIndex]._CurrentIndex;
            for(uint Index; Index < DesiredAmount; Index++) { _NFT.transferFrom(_Operator, Purchaser, _StartingIndex + Index); }
            FixedPriceSales[SaleIndex]._CurrentIndex += DesiredAmount;
        }
        else if (FixedPriceSales[SaleIndex]._Type == 4)
        {
            IMinter _NFT = IMinter(FixedPriceSales[SaleIndex]._NFT);
            uint _BatchPurchaseAmount = FixedPriceSales[SaleIndex]._BatchPurchaseAmount;
            uint _ETHValue = FixedPriceSales[SaleIndex]._Price / _BatchPurchaseAmount;
            uint _MinterProjectID = FixedPriceSales[SaleIndex]._MinterProjectID;
            for(uint x; x < DesiredAmount; x++) // Iterates Over The Desired Units Of Purchase
            {
                for(uint y; y < _BatchPurchaseAmount; y++) // Mints Configured Amount Of NFTs Per Unit Purchased
                { 
                    _NFT.purchaseTo{value: _ETHValue}(Purchaser, _MinterProjectID); 
                }
            }
        }
        else { revert('Marketplace: Incorrect Sale Configuration'); }
        UserPurchasedAmount[SaleIndex][Purchaser] += DesiredAmount;
        ETHRevenueFixedPriceSale[SaleIndex] += MessageValue;
        emit Purchased(SaleIndex, Purchaser, DesiredAmount, Priority);
    }

    /**
     * @dev Finalizes A Presale Purchase
     * @param SaleIndex The Sale Index To Purchase
     * @param DesiredAmount The Desired Amount To Purchase
     * @param MaxAmount The Maximum Amount For Merkle Priority Purchase
     * @param Vault Delegate Vault Address
     * @param Proof Merkle Proof For Eligibility
     * @param ProofAmount Merkle Proof For MaxAmount
     */
    function __FinalizePresale(
        uint SaleIndex,
        uint DesiredAmount,
        uint MaxAmount,
        address Vault,
        bytes32[] calldata Proof,
        bytes32[] calldata ProofAmount,
        uint MessageValue,
        address Purchaser
    ) internal {
        require(tx.origin == Purchaser, "Marketplace: EOA Only");
        require(block.timestamp >= PresaleSales[SaleIndex]._TimestampSaleStart, "Marketplace: Sale Not Started");
        address MerkleRecipient = Purchaser;
        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(Purchaser, Vault)) { MerkleRecipient = Vault; } }
        InternalPresaleSale memory _InternalPresaleSale = PresaleSalesInternal[SaleIndex];
        SaleTypePresale memory _PresaleSale = PresaleSales[SaleIndex];
        bool PresaleEnded;
        uint _Price;
        uint _MaxPerPurchase = _PresaleSale._MaxPerPurchase;
        if(_InternalPresaleSale._AmountSold + DesiredAmount > _PresaleSale._MaxForSale) 
        { 
            DesiredAmount = _PresaleSale._MaxForSale - _InternalPresaleSale._AmountSold; // Partial Fill
        } 
        if(block.timestamp <= _PresaleSale._TimestampEndCitizen) // Presale
        {
            if(block.timestamp <= _PresaleSale._TimestampEndFullSet) // Full Set Window
            { 
                require ( // Eligible For Full Set Window
                    VerifyBrightList(MerkleRecipient, InternalRoots[SaleIndex]._RootEligibilityFullSet, Proof), 
                    "Full Set Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds..."
                ); 
                require(VerifyAmount(MerkleRecipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmount), "Invalid Full Set Amount Proof");
                require(InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedWallet + DesiredAmount <= MaxAmount, "All Full Set Allocation Used");
                InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedFullSetWindow += DesiredAmount;
                PresaleSalesInternal[SaleIndex]._GlobalPurchasesFullSet += DesiredAmount;
                emit Fullset();
            }
            else // Citizen Window
            { 
                require ( // Eligible For Citizen Window
                    VerifyBrightList(MerkleRecipient, InternalRoots[SaleIndex]._RootEligibilityCitizen, Proof), 
                    "Citizen Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds..."
                ); 
                require(VerifyAmount(MerkleRecipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmount), "Invalid Citizen Amount Proof");
                require(InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedCitizenWindow + DesiredAmount <= MaxAmount, "All Citizen Allocation Used");
                InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedWallet += DesiredAmount;
                PresaleSalesInternal[SaleIndex]._GlobalPurchasesCitizen += DesiredAmount;
                emit Citizen();
            }
            _Price = _PresaleSale._PricePresale * DesiredAmount;
        }
        else // Public Sale
        { 
            _Price = _PresaleSale._PricePublic * DesiredAmount;
            PresaleSalesInternal[SaleIndex]._GlobalPurchasesPublic += DesiredAmount;
            PresaleEnded = true; 
            emit Public();
        }
        require(DesiredAmount <= _MaxPerPurchase, "Invalid Desired Purchase Amount. Must Be <= Max Purchase Limit"); // Purchase Limiter
        require(_InternalPresaleSale._AmountSold + DesiredAmount <= _PresaleSale._MaxForSale, "Sale Ended"); // Sale End State
        require(DesiredAmount > 0 && _Price > 0, "Sale Ended"); // Sale End State
        require(MessageValue >= _Price, "Invalid ETH Amount"); // Ensures ETH Amount Sent Is Correct
        if(MessageValue > _Price) // Refunds The Difference
        { 
            uint Value = MessageValue - _Price;
            (bool Confirmed,) = Purchaser.call{value: Value}(""); 
            require(Confirmed, "Marketplace: Refund failed");
            emit Refunded(Purchaser, Value);
        } 
        if(_PresaleSale._Type == 0) { IMinter(_PresaleSale._NFT)._MintToFactory(0, Purchaser, DesiredAmount); }
        else if (_PresaleSale._Type == 1) 
        { 
            for(uint x; x < DesiredAmount; x++) { IMinter(_PresaleSale._NFT).purchaseTo(Purchaser, _PresaleSale._ProjectID); }
        }
        PresaleSalesInternal[SaleIndex]._AmountSold += DesiredAmount;
        PresaleSalesInternal[SaleIndex]._CurrentTokenIndex += DesiredAmount;
        PresaleSalesInternal[SaleIndex]._ETHRevenue += _Price;
        InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedWallet += DesiredAmount;
        emit PurchasedPresale(SaleIndex, Purchaser, DesiredAmount, MessageValue, PresaleEnded);
    }

    /**
     * @dev Returns The Sale Info For A Fixed Price Sale
     * @param SaleIndex The Sale Index To View
     * @param Wallet The Wallet To View
     * @param MaxAmount The Maximum Amount To View
     * @param ProofEligibility The Merkle Proof For Eligibility
     * @param ProofAmount The Merkle Proof For Amount
     * @return FixedPriceSaleInfo The Sale Information
     */
    function __ViewSaleInfoFixedPrice (
        uint SaleIndex,
        address Wallet,
        uint MaxAmount,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) internal view returns (FixedPriceSaleInfo memory) {
        uint Price = FixedPriceSales[SaleIndex]._Price;
        uint AmountForSale = FixedPriceSales[SaleIndex]._AmountForSale;
        uint AmountRemaining = AmountForSale - AmountSoldFixedPrice[SaleIndex];
        uint ETHRevenue = ETHRevenueFixedPriceSale[SaleIndex];
        uint AmountPurchasedUser = UserPurchasedAmount[SaleIndex][Wallet];
        uint AmountRemainingMerklePriority;
        uint PurchasedAmountMerklePriority;
        bool BrightListMerkleAmount;
        uint[] memory DiscountAmountWEIValues = new uint[](FixedPriceSales[SaleIndex]._RootEligibilities.length);
        for(uint x; x < FixedPriceSales[SaleIndex]._RootEligibilities.length; x++)
        {
            DiscountAmountWEIValues[x] = (Price * DiscountAmounts[SaleIndex][x]) / 100;
        }
        (bool BrightListEligible, uint Priority) = VerifyBrightListWithPriority(
            SaleIndex, 
            Wallet, 
            ProofEligibility
        );
        if(BrightListEligible)
        {
            BrightListMerkleAmount = VerifyBrightListAmount(Wallet, MaxAmount, FixedPriceSales[SaleIndex]._RootAmounts[Priority], ProofAmount);
            PurchasedAmountMerklePriority = PriorityPurchaseAmount[SaleIndex][Wallet][Priority];
            if(MaxAmount > PurchasedAmountMerklePriority)
            {
                AmountRemainingMerklePriority = MaxAmount - PurchasedAmountMerklePriority;
            }
        }
        return FixedPriceSaleInfo(
            FixedPriceSales[SaleIndex]._Name,
            Price, 
            FixedPriceSales[SaleIndex]._MintPassProjectID,
            FixedPriceSales[SaleIndex]._Type,
            FixedPriceSales[SaleIndex]._MinterProjectID,
            AmountForSale, 
            FixedPriceSales[SaleIndex]._TimestampStart,
            FixedPriceSales[SaleIndex]._CurrentIndex,
            FixedPriceSales[SaleIndex]._BatchPurchaseAmount,
            FixedPriceSales[SaleIndex]._NFT,
            FixedPriceSales[SaleIndex]._Operator,
            FixedPriceSales[SaleIndex]._RootEligibilities,
            FixedPriceSales[SaleIndex]._RootAmounts,
            DiscountAmountWEIValues,
            ETHRevenue, 
            AmountRemaining, 
            Priority, 
            AmountRemainingMerklePriority,
            AmountPurchasedUser,
            BrightListEligible, 
            BrightListMerkleAmount
        );
    }
}

interface IERC721 { function transferFrom(address From, address To, uint TokenID) external; }
interface ILiveMint { function _LiveMintMarketplace(address Recipient, uint ArtistID, uint Amount) external; }
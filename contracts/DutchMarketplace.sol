//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 * @title: DutchMarketplace
 * @notice: Dutch Auction Marketplace With Discounted Priority Tiers, Credit Respend, & Settlement
 */
pragma solidity 0.8.19;
import { MissionControl } from "./MissionControl.sol";
import { IMP } from "./IMP.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { MerkleProof } from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
contract DutchMarketplace is MissionControl, ReentrancyGuard
{
    struct Sale
    {
        string _Name;                     // [0] -> _Name
        uint _ProjectIDArtBlocks;         // [1] -> _ProjectIDArtBlocks
        uint _PriceStart;                 // [2] -> _PriceStart
        uint _PriceEnd;                   // [3] -> _PriceEnd
        uint _MaxAmtPerPurchase;          // [4] -> _MaxAmtPerPurchase
        uint _MaximumAvailableForSale;    // [5] -> _MaximumAvailableForSale
        uint _StartingBlockUnixTimestamp; // [6] -> _StartingBlockUnixTimestamp
        uint _SecondsBetweenPriceDecay;   // [7] -> _SecondsBetweenPriceDecay
        uint _MintPackAmount;             // [8] -> _MintPackAmount note: For MintPack Sales, This Is The Default Amount Of Tokens To Mint Per Purchase Per Amount 
    }

    struct InternalSale
    {
        address _NFT;           // [0] -> _NFT
        address _Operator;      // [1] _Operator (Wallet That NFT Is Pulling From)
        uint _CurrentIndex;     // [2] _CurrentIndex (If Simple Sale Type, This Is The Next Token Index To Iterate Upon)
        uint _Type;             // [3] _SaleType (0 = Factory MintPass, 1 = Factory MintPack, 2 = transferFrom(), 3 = purchaseTo(), 4 = MintPack transferFrom())
        bool _ActivePublic;     // [4] -> _ActivePublic
        bool _ActiveBrightList; // [5] -> _ActiveBrightList 
        bool _ActiveDiscount;   // [6] -> _ActiveDiscount
        bool _ActiveRespend;    // [7] -> _ActiveRespend
    }

    struct SaleParam
    {
        bytes32[] _Roots;        // [0] -> _Roots (Merkle Roots For BrightList)
        bytes32[] _RootsAmounts; // [1] -> _RootsAmounts (Merkle Roots For BrightList Amounts)
        uint[] _DiscountAmounts; // [2] -> _DiscountAmounts (Discount Amounts For Each Discount Priority Tier)
    }

    struct MiscSale
    {
        uint _AmountSold;         // [0] -> _AmountSold
        uint _UniqueSales;        // [1] -> _UniqueSales
        uint _FinalClearingPrice; // [2] -> _FinalClearingPrice
        uint _CurrentRefundIndex; // [3] -> _CurrentRefundIndex
    }

    struct Order
    {
        address _Purchaser;       // [0] _Purchaser
        uint _PurchaseValue;      // [1] _PurchaseValue
        uint _PurchaseAmount;     // [2] _PurchaseAmount
        uint _Priority;           // [3] _BrightList Priority Status note: (0 Is Highest Priority)
        bool _BrightListPurchase; // [4] _BrightListPurchase
        bool _Claimed;            // [5] _Claimed
    }

    struct _UserSaleInformation
    {
        uint[] _UserOrderIndexes;        // [0] -> _UserOrderIndexes         | The Indexes Of The User's Orders
        uint[] _AmountPurchasedPriority; // [1] -> _AmountPurchasedPriority  | The Amount Of Tokens Purchased By The User For The Provided Priority
        uint _PurchasedAmount;           // [2] -> _PurchaseAmount           | The Amount Of Tokens Purchased By The User
        uint _RemainingPurchaseAmount;   // [3] -> _RemainingPurchaseAmount  | The Amount Of Tokens Remaining To Be Purchased Specifically For The User
        uint _ClaimIndex;                // [4] -> _ClaimIndex               | If ETH-Claims Are Enabled, This Is The User's Current Claim Index
        uint _AmountRemaining;           // [5] -> _AmountRemaining          | The Amount Of Tokens Remaining To Be Sold
        uint _CurrentPrice;              // [6] -> _MintPassCurrentPrice     | The Current Price Of The Token To Be Sold
        uint _Priority;                  // [7] -> _Priority For BrightList  | The User's Priority For The BrightList | note: (0 Is Highest Priority) 
        uint _Credit;                    // [8] -> _Credit                   | The Amount Of Credit / Rebate Owed To The User (Without Discount) 
        bool _BrightListEligible;        // [9] -> _BrightListEligible       | If The User Is Eligible For The BrightList
        bool _MaxAmountVerified;         // [10] -> _MaxAmountVerified       | If The User Passed MaxAmount Correctly
        bool _ActiveRespend;             // [11] -> _ActiveRespend           | If Purchase Credit Is Able To Be Used
        bool _Active;                    // [12] -> _Active                  | If The Sale Is Active
    }

    struct Info
    {
        uint _CurrentPrice;            // [0] -> _CurrentPrice
        uint _MaximumAvailableForSale; // [1] -> _MaximumAvailableForSale
        uint _AmountRemaining;         // [2] -> _AmountRemaining
        bool _Active;                  // [3] -> _Active
    }

    /*------------------
     * STATE VARIABLES *
    -------------------*/

    uint public _TOTAL_UNIQUE_SALES_DUTCH;                                               // Total Unique Dutch Sales
    uint private constant _DEFAULT_PRIORITY = 69420;                                     // Default Priority Value               
    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;           // 😉 `delegate.cash` Delegation Registry 
    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`
    
    /*-----------
     * MAPPINGS *
    ------------*/

    mapping(uint=>Sale) public Sales;                                                   // [SaleIndex] => Sale
    mapping(uint=>MiscSale) public SaleState;                                           // [SaleIndex] => MiscSale
    mapping(uint=>InternalSale) public SalesInternal;                                   // [SaleIndex] => InternalSale
    mapping(uint=>Order[]) public Orders;                                               // [SaleIndex][UniqueSaleIndex] => Order
    mapping(uint=>mapping(address=>_UserSaleInformation)) public UserInfo;              // [SaleIndex][Wallet] => UserInfo
    mapping(uint=>SaleParam) private SaleParams;                                        // [SaleIndex] => SaleParam
    mapping(address=>uint) public NFTAddressToSaleIndex;                                // [NFT Address] => SaleIndex
    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount; // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level

    /*---------
     * EVENTS *
    ----------*/

    /**
     * @dev Emitted When NFTs Are Purchased
     * @param SaleIndex      | The Sale Index To Edit
     * @param Purchaser      | The Purchaser
     * @param Amount         | The Amount Of NFTs Purchased
     * @param PurchaseValue  | The Value Of The Purchase
     * @param NewAmountSold  | The New Amount Sold
     * @param BrightList     | If The Purchase Was BrightList
     * @param Priority       | The Priority Of The Purchase
     * @param AppliedCredit  | The Amount Of Credit Applied
     */
    event Purchased(uint SaleIndex, address Purchaser, uint Amount, uint PurchaseValue, uint NewAmountSold, bool BrightList, uint Priority, uint AppliedCredit);

    /**
     * @dev Emitted When ETH Is Refunded
     * @param Value | The Value Refunded
     */
    event Refunded(uint Value);

    /**
     * @dev Emitted When A Sale Cannot Be Finalized
     * @param SaleIndex  | The Sale Index To Edit
     * @param OrderIndex | The Order Index
     */
    event OrderRefundFailed(uint SaleIndex, uint OrderIndex);

    /**
     * @dev Emitted When A Sale Is Started
     * @param SaleIndex | The Sale Index To Edit
     */
    event SaleStarted(uint SaleIndex);

    /**
     * @dev Emitted When A Sale Is Ended
     * @param SaleIndex  | The Sale Index To Edit
     * @param OrderIndex | The Order Index
     */
    event RefundClaimed(uint SaleIndex, uint OrderIndex);    

    /*---------------------
     * EXTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Purchases NFTs At The Current Dutch Auction Price
     * @notice IF YOU PURCHASE THROUGH THE CONTRACT WITHOUT THE FRONTEND YOU WILL NOT BE ELIGIBLE FOR A DISCOUNT REBATE, REQUIRES A MERKLE PROOF
     * @param SaleIndex The Sale Index To Edit
     * @param PurchaseAmount The Amount Of NFTs To Purchase
     * @param MaxAmount Optional Maximum Brightlist Purchase Per Wallet Limiter
     * @param Vault Vault (optional delegate.cash) (if opt-out, use address(0) or `0x0000000000000000000000000000000000000000`)
     * @param ProofEligibility Merkle Proof For Priority Discount Eligibility
     * @param ProofAmount Merkle Proof For Maximum Purchase PurchaseAmount
     * note: @param ProofEligibility Input --> [0x0] <-- For Empty Proof
     * note: @param ProofAmount - Input --> [0x0] <-- For Empty Proof
     */
    function Purchase (
        uint SaleIndex, 
        uint PurchaseAmount, 
        uint MaxAmount, 
        address Vault, 
        bytes32[] calldata ProofEligibility, 
        bytes32[] calldata ProofAmount
    ) external payable nonReentrant { 
        require(tx.origin == msg.sender, "DutchMarketplace: EOA Only, Use `delegate.cash` For Wallet Delegation");
        InternalSale memory _IS = SalesInternal[SaleIndex];
        require(block.timestamp >= Sales[SaleIndex]._StartingBlockUnixTimestamp, "DutchMarketplace: Sale Not Started");
        require(_IS._ActivePublic || _IS._ActiveBrightList, "DutchMarketplace: Sale Not Active");
        address MerkleAddress = msg.sender;
        address Purchaser = MerkleAddress;
        uint OrderIndex = SaleState[SaleIndex]._UniqueSales;
        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(Purchaser, Vault)) { MerkleAddress = Vault; } } 
        require(MerkleAddress != address(0), "DutchMarketplace: Invalid Recipient");
        if(SaleState[SaleIndex]._AmountSold + PurchaseAmount > Sales[SaleIndex]._MaximumAvailableForSale)
        {
            PurchaseAmount = Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold;
        }
        uint NewAmountSold = SaleState[SaleIndex]._AmountSold + PurchaseAmount;
        require(NewAmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, "DutchMarketplace: Sold Out");
        uint Priority = _DEFAULT_PRIORITY;
        bool BrightListEligible;
        if(_IS._ActiveBrightList)
        {
            (BrightListEligible, Priority) = ViewBrightListStatus(SaleIndex, MerkleAddress, ProofEligibility);
            if(BrightListEligible)
            {
                uint UserPriorityPurchasedAmount = PriorityPurchaseAmount[SaleIndex][MerkleAddress][Priority];
                bytes32 _RootHash = SaleParams[SaleIndex]._RootsAmounts[Priority];
                require(__VerifyAmount(MerkleAddress, MaxAmount, _RootHash, ProofAmount), "DutchMarketplace: Invalid Max Amount Merkle Proof For Provided Merkle Priority");
                require(UserPriorityPurchasedAmount + PurchaseAmount <= MaxAmount, "DutchMarketplace: User Has Purchased All Allocation For Provided Merkle Priority");
                PriorityPurchaseAmount[SaleIndex][MerkleAddress][Priority] += PurchaseAmount;
            }
        }
        require(PurchaseAmount > 0 && PurchaseAmount <= Sales[SaleIndex]._MaxAmtPerPurchase, "DutchMarketplace: Incorrect Desired Purchase Amount");
        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);
        uint PurchaseValue = CurrentPrice * PurchaseAmount;
        uint AppliedCredit;
        if(_IS._ActiveRespend) { AppliedCredit = __ActiveRespend(SaleIndex, CurrentPrice, PurchaseValue, Purchaser); } // AppliedCredit Is Capped @ Purchase Value
        uint TotalETHContributed = msg.value + AppliedCredit;
        require(TotalETHContributed >= PurchaseValue, "DutchMarketplace: Incorrect ETH PurchaseAmount Sent");
        if(TotalETHContributed > PurchaseValue && msg.value > 0) { __Refund(Purchaser, TotalETHContributed - PurchaseValue); }
        Orders[SaleIndex].push(Order(Purchaser, PurchaseValue, PurchaseAmount, Priority, BrightListEligible, false));
        UserInfo[SaleIndex][Purchaser]._UserOrderIndexes.push(OrderIndex);
        UserInfo[SaleIndex][Purchaser]._PurchasedAmount = UserInfo[SaleIndex][Purchaser]._PurchasedAmount + PurchaseAmount;
        SaleState[SaleIndex]._UniqueSales = OrderIndex + 1;
        SaleState[SaleIndex]._AmountSold = NewAmountSold;
        require(SaleState[SaleIndex]._AmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, "DutchMarketplace: Overflow");
        if(SaleState[SaleIndex]._AmountSold == Sales[SaleIndex]._MaximumAvailableForSale)
        { 
            SaleState[SaleIndex]._FinalClearingPrice = CurrentPrice;
            __EndSale(SaleIndex);
        }
        if(_IS._Type == 0) { IERC721(_IS._NFT)._MintToFactory(Purchaser, PurchaseAmount); } // Factory MintPass Direct Mint
        else if (_IS._Type == 1) { IERC721(_IS._NFT)._MintToFactoryPack(Purchaser, PurchaseAmount); } // Factory MintPack Direct Mint
        else if (_IS._Type == 2) // transferFrom() Sale Implementation (NFTs Already Minted)
        {
            for(uint x; x < PurchaseAmount; x++)
            {
                IERC721(_IS._NFT).transferFrom(
                    _IS._Operator,        // `from`
                    Purchaser,            // `to`
                    _IS._CurrentIndex + x // `tokenID`
                );
            }
            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + PurchaseAmount;
        }
        else if (_IS._Type == 3) // purchaseTo() Sale Implementation
        {
            uint ProjectID = Sales[SaleIndex]._ProjectIDArtBlocks;
            for(uint x; x < PurchaseAmount; x++)
            {
                IERC721(_IS._NFT).purchaseTo(
                    Purchaser, // `to`
                    ProjectID  // `projectID`
                );
            }
        }
        else if (_IS._Type == 4) // transferFrom() MintPack Sale Implementation (NFTs Already Minted)
        {
            uint _MintPackAmount = Sales[SaleIndex]._MintPackAmount;
            uint _Start = _IS._CurrentIndex;
            for(uint x; x < PurchaseAmount; x++)
            {
                for(uint y; y < _MintPackAmount; y++)
                {
                    IERC721(_IS._NFT).transferFrom(
                        _IS._Operator, // `from`
                        Purchaser,     // `to`
                        _Start + y     // `tokenID`
                    );
                }
                _Start += _MintPackAmount;
            }
            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + (_MintPackAmount * PurchaseAmount);
        }
        else { revert("DutchMarketplace: Incorrect Sale Configuration"); }
        emit Purchased(SaleIndex, Purchaser, PurchaseAmount, PurchaseValue, NewAmountSold, BrightListEligible, Priority, AppliedCredit);
    }

    /*---------------------
     * OPERATOR FUNCTIONS *
    ----------------------*/

    /**
     * @dev Starts A Sale
     * @param _Sale The Sale
     * @param _InternalSale The Internal Sale
     * @param RootsPriority The Merkle Roots For BrightList Priority
     * @param RootsAmounts The Merkle Roots For BrightList Amounts
     * @param DiscountAmounts The Discount Amounts
     */
    function _StartSale (
        Sale memory _Sale,
        InternalSale memory _InternalSale,
        bytes32[] calldata RootsPriority,
        bytes32[] calldata RootsAmounts,
        uint[] calldata DiscountAmounts
    ) external onlyOperator returns (uint SaleIndex) {
        SaleIndex = _TOTAL_UNIQUE_SALES_DUTCH;
        NFTAddressToSaleIndex[_InternalSale._NFT] = SaleIndex;
        Sales[SaleIndex] = _Sale;
        SalesInternal[SaleIndex] = _InternalSale;
        SaleParams[SaleIndex] = SaleParam(RootsPriority, RootsAmounts, DiscountAmounts);
        require(_InternalSale._Type >= 0 && _InternalSale._Type <= 4, "DutchMarketplace: Invalid Sale Type");
        require(RootsPriority.length == DiscountAmounts.length, "DutchMarketplace: Array Lengths Must Match");
        for(uint x; x < SaleParams[SaleIndex]._DiscountAmounts.length; x++) { require(DiscountAmounts[x] <= 100, "DutchMarketplace: Invalid Discount Amount"); }
        require(Sales[SaleIndex]._PriceStart >= Sales[SaleIndex]._PriceEnd, "DutchMarketplace: Invalid Start And End Prices");
        emit SaleStarted(SaleIndex);
        _TOTAL_UNIQUE_SALES_DUTCH++;
        return SaleIndex;
    }

    /**
     * @dev Initiates Withdraw Of Refunds & Sale Proceeds
     * @param SaleIndex The Sale Index To Edit
     * note: This Is Only After The Sale Has Completed
     */
    function _InitiateRefundsAndProceeds(uint SaleIndex) external nonReentrant onlyOperator 
    {
        bool _TxConfirmed;
        uint _Proceeds;
        uint _Refund;
        require(SaleState[SaleIndex]._FinalClearingPrice > 0, "DutchMarketplace: Final Clearing Price Not Seeded");
        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;
        for(uint OrderIndex = SaleState[SaleIndex]._CurrentRefundIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)
        {
            Order memory _Order = Orders[SaleIndex][OrderIndex];
            if(!_Order._Claimed)
            {
                if(!_Order._BrightListPurchase) // No BrightList
                {
                    _Refund = _Order._PurchaseValue - (SaleState[SaleIndex]._FinalClearingPrice * _Order._PurchaseAmount);
                    _Proceeds += _Order._PurchaseValue - _Refund;
                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(""); }
                }
                else // BrightList
                {
                    _Refund = _Order._PurchaseValue - 
                    (
                        ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100)
                        * 
                        _Order._PurchaseAmount
                    );
                    _Proceeds += _Order._PurchaseValue - _Refund;
                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(""); }
                }
                if(!_TxConfirmed) { emit OrderRefundFailed(SaleIndex, OrderIndex); }
                Orders[SaleIndex][OrderIndex]._Claimed = true;
            }
        }
        (_TxConfirmed,) = _BRT_MULTISIG.call{ value: _Proceeds }(""); 
        require(_TxConfirmed, "DutchMarketplace: Multisig Refund Failed, Use Failsafe Withdraw And Manually Process");
        SaleState[SaleIndex]._CurrentRefundIndex = SaleState[SaleIndex]._UniqueSales; // Resets Refund Index
    }

    /**
     * @dev Modifies The Sale Starting Token Index
     * @param SaleIndex The Sale Index To Edit To Edit
     * @param StartingTokenID The New Starting Token Index
     * note: If `Simple` Sale, Then This Is The Current TokenID Being Transferred In The Sale
     */
    function _ModifySaleStartingTokenIndex(uint SaleIndex, uint StartingTokenID) external onlyOperator
    {
        SalesInternal[SaleIndex]._CurrentIndex = StartingTokenID;
    }

    /**
     * @dev Modifies The Sale Name
     * @param SaleIndex The Sale Index To Edit
     * @param Name The New Sale Name
     */
    function _ModifySaleName(uint SaleIndex, string calldata Name) external onlyOperator
    {
        Sales[SaleIndex]._Name = Name;
    }

    /**
     * @dev Modifies The Starting Price
     * @param SaleIndex The Sale Index To Edit
     * @param PriceStart The New Starting Price
     * @notice This Is The Price At Which The Sale Begins
     */
    function _ModifyPriceStart(uint SaleIndex, uint PriceStart) external onlyOperator
    {
        Sales[SaleIndex]._PriceStart = PriceStart;
    }

    /**
     * @dev Modifies The Ending Price
     * @param SaleIndex The Sale Index To Edit
     * @param PriceEnd The New Ending Price
     * @notice This Is The Price At Which The Sale Rests At
     */
    function _ModifyPriceEnd(uint SaleIndex, uint PriceEnd) external onlyOperator
    {
        Sales[SaleIndex]._PriceEnd = PriceEnd;
    }

    /**
     * @dev Modifies The Per-Wallet-Limiter
     * @param SaleIndex The Sale Index To Edit
     * @param MaxAmtPerPurchase The New Maximum Amount Per Purchase
     * @notice This Is The Maximum Amount Of NFTs That Can Be Purchased Per Wallet Per Transaction
     */
    function _ModifyMaxAmtPerPurchase(uint SaleIndex, uint MaxAmtPerPurchase) external onlyOperator
    {
        Sales[SaleIndex]._MaxAmtPerPurchase = MaxAmtPerPurchase;
    }

    /**
     * @dev Modifies The Maximum NFTs For Sale
     * @param SaleIndex The Sale Index To Edit
     * @param AmountForSale The New Maximum Amount For Sale
     * @notice This Is The Maximum Amount Of NFTs That Can Be Sold In The Sale
     */
    function _ModifyMaxForSale(uint SaleIndex, uint AmountForSale) external onlyOperator
    {
        Sales[SaleIndex]._MaximumAvailableForSale = AmountForSale;
    }

    /**
     * @dev Modifies The Starting Unix Timestamp
     * @param SaleIndex The Sale Index To Edit
     * @param Timestamp The New Starting Unix Timestamp
     * @notice This Is The Block Timestamp That The Sale Begins
     */
    function _ModifyTimestampStart(uint SaleIndex, uint Timestamp) external onlyOperator
    {
        Sales[SaleIndex]._StartingBlockUnixTimestamp = Timestamp;
    }

    /**
     * @dev Modifies The Price Decay (Input In Seconds)
     * @param SaleIndex The Sale Index To Edit
     * @param PriceDecayInSeconds The New Price Decay In Seconds
     * @notice This Is How Many Seconds The Sale Will Halve In Price (Half Life)
     */
    function _ModifyPriceDecay(uint SaleIndex, uint PriceDecayInSeconds) external onlyOperator
    {
        Sales[SaleIndex]._SecondsBetweenPriceDecay = PriceDecayInSeconds;
    }

    /**
     * @dev Modifies The Sale Discount Amount
     * @param SaleIndex The Sale Index To Edit
     * @param DiscountAmounts The New Discount Amounts
     * @notice DiscountAmounts Of [75, 90] = [25%, 10%] Discounts
     */
    function _ModifySaleDiscountAmount(uint SaleIndex, uint[] calldata DiscountAmounts) external onlyOperator
    {
        for(uint x; x < DiscountAmounts.length; x++)
        {
            require(DiscountAmounts[x] <= 100, "DutchMarketplace: Invalid Discount Amount");
            SaleParams[SaleIndex]._DiscountAmounts[x] = DiscountAmounts[x];
        }
    }

    /**
     * @dev Modifies The NFT Address Of A Sale
     * @param SaleIndex The Sale Index To Edit
     * @param NFT The New NFT Address
     */
    function _ModifySaleNFTAddress(uint SaleIndex, address NFT) external onlyOperator
    {
        SalesInternal[SaleIndex]._NFT = NFT;
    }

    /**
     * @dev Modifies The Final Clearing Price Of A Sale IN WEI
     * @param SaleIndex The Sale Index To Edit
     * @param ClearingPrice The New Clearing Price
     * @notice This Is The Price At Which The Sale Proceeds, Rebates, & Discounts Are Calculated
     */
    function _ModifySaleClearingPrice(uint SaleIndex, uint ClearingPrice) external onlyOperator
    {
        SaleState[SaleIndex]._FinalClearingPrice = ClearingPrice;
    }

    /**
     * @dev Modifies The Public Active Sale State
     * @param SaleIndex The Sale Index To Edit
     * @param State The New State
     * @notice This Enables Any User To Purchase NFTs At The Current Price
     */
    function _ModifySaleStatePublic(uint SaleIndex, bool State) external onlyOperator
    {
        SalesInternal[SaleIndex]._ActivePublic = State;
    }

    /**
     * @dev Modifies The BrightList Active Sale State
     * @param SaleIndex The Sale Index To Edit
     * @param State The New State
     * @notice This Enables Users To Purchase NFTs At A Discounted Rate If They Are On The BrightList
     */
    function _ModifySaleStateBrightList(uint SaleIndex, bool State) external onlyOperator { SalesInternal[SaleIndex]._ActiveBrightList = State; }

    /**
     * @dev Modifies The State Of ETH Claims
     * @param SaleIndex The Sale Index To Edit
     * @param State The New State
     * @notice This Enables Users To Claim ETH Rebate Pending In The Contract Before The Sale Sells Out
     */
    function _ModifySaleETHClaimsEnabled(uint SaleIndex, bool State) external onlyOperator { SalesInternal[SaleIndex]._ActiveRespend = State; }

    /**
     * @dev Modifies The Merkle Root(s) For Amounts
     * @param SaleIndex The Sale Index To Edit
     * @param RootsAmounts The New Roots For Amounts
     */
    function _ModifySaleRootAmounts(uint SaleIndex, bytes32[] calldata RootsAmounts) external onlyOperator { SaleParams[SaleIndex]._RootsAmounts = RootsAmounts; }

    /**
     * @dev Modifies The Merkle Root(s) For Eligibility
     * @param SaleIndex The Sale Index To Edit
     * @param Roots The New Roots For Eligibility
     */
    function _ModifySaleRootEligibility(uint SaleIndex, bytes32[] calldata Roots) external onlyOperator { SaleParams[SaleIndex]._Roots = Roots; }

    /**
     * @dev Modifies The Sale Root(s) For Merkle Eligibility & Amounts
     * @param SaleIndex The Sale Index To Edit
     * @param RootsEligibility The New Roots For Eligibility
     * @param RootsAmounts The New Roots For Amounts
     */
    function _ModifySaleRoots(uint SaleIndex, bytes32[] calldata RootsEligibility, bytes32[] calldata RootsAmounts) external onlyOperator
    {
        SaleParams[SaleIndex]._Roots = RootsEligibility;
        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;
    }

    /**
     * @dev Modifies Sale Struct
     * @param SaleIndex The Sale Index To Edit
     * @param _Sale The New Sale Struct
     */
    function _ModifySale(uint SaleIndex, Sale memory _Sale) external onlyOperator { Sales[SaleIndex] = _Sale; }

    /**
     * @dev Modifies The Sale Operator
     * @param SaleIndex The Sale Index To Edit
     * @param Operator The New Operator
     * @notice This Is The Address/Wallet That transferFrom() Sales Will Pull NFTs From
     */
    function _ModifySaleOperator(uint SaleIndex, address Operator) external onlyOperator { SalesInternal[SaleIndex]._Operator = Operator; }

    /**
     * @dev Modifies The Sale Type
     * @param SaleIndex The Sale Index To Edit
     * @param Type The New Type
     * @notice Type 0 = Factory MintPass, 1 = Factory MintPack, 2 = transferFrom(), 3 = purchaseTo(), 4 = MintPack transferFrom()
     */
    function _ModifySaleType(uint SaleIndex, uint Type) external onlyOperator { SalesInternal[SaleIndex]._Type = Type; }

    /**
     * @dev Modifies The Sale Starting TokenID
     * @param SaleIndex The Sale Index To Edit
     * @param TokenID The New TokenID
     * @notice This Changes TokenID That The Sale Will Transfer On Purchase, This Variable Will Increment Sequentially As Purchases Are Made
     */
    function _ModifySaleStartingTokenID(uint SaleIndex, uint TokenID) external onlyOperator { SalesInternal[SaleIndex]._CurrentIndex = TokenID; }

    /**
     * @dev Withdraws All ETH To The Multisig
     * @param Amount The Amount To Withdraw
     * @notice This Is A Emergency Withdraw Function That Is Only Intended To Be Used If There Is An Issue With Settlement
     */
    function _WithdrawEtherToMultisig(uint Amount) external onlyOperator
    {
        (bool Success, ) = _BRT_MULTISIG.call{value: Amount}("");
        require(Success, "DutchMarketplace: Unable to Withdraw, Recipient May Have Reverted");
    }
    
    /*--------------*/
    /*  ONLY OWNER  */
    /*--------------*/

    /**
     * @dev Withdraws All Ether From The Contract
     * @notice This Is A Emergency Withdraw Function That Is Only Intended To Be Used If There Is An Issue With Settlement
     */
    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Executes Arbitrary Transaction(s)
     * @param Targets The Addresses To Execute Transactions On
     * @param Values The Values To Send In Wei
     * @param Datas The Data To Execute
     */
    function ___InitTransactions(address[] memory Targets, uint[] memory Values, bytes[] memory Datas) external onlyOwner
    {
        for(uint x; x < Targets.length; x++) 
        {
            (bool success,) = Targets[x].call{value:(Values[x])}(Datas[x]);
            require(success, "i have failed u anakin");
        }
    }

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/

    /**
     * @dev Returns Sale Information For A Given Wallet At `SaleIndex`
     * @param SaleIndex        | The Sale Index To Edit
     * @param Wallet           | The Currently Connected Wallet
     * @param MaxAmount        | The Max Amount Of Tokens The User Can Purchase
     * @param Vault            | The Vault Address
     * @param ProofEligibility | The Proof For The BrightList
     * @param ProofAmount      | The Proof For The MaxAmount
     */
    function ViewWalletSaleInformation (
        uint SaleIndex,
        address Wallet,
        uint MaxAmount,
        address Vault,
        bytes32[] calldata ProofEligibility,
        bytes32[] calldata ProofAmount
    ) public view returns ( _UserSaleInformation memory ) {
        uint[] memory PriorityPurchaseAmounts = new uint[](SaleParams[SaleIndex]._Roots.length);
        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);
        uint PurchasableAmount;
        uint Priority;
        bool Verified;
        bool VerifiedAmount;
        bool Active = SalesInternal[SaleIndex]._ActiveBrightList || SalesInternal[SaleIndex]._ActivePublic;
        bool ActiveRespend = SalesInternal[SaleIndex]._ActiveRespend;
        uint Credit = ViewPendingCredit(SaleIndex, Wallet);
        uint UserPurchasedAmount = UserInfo[SaleIndex][Wallet]._PurchasedAmount;
        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(Wallet, Vault)) { Wallet = Vault; } }
        for(uint x; x < SaleParams[SaleIndex]._Roots.length; x++) 
        { 
            PriorityPurchaseAmounts[x] = PriorityPurchaseAmount[SaleIndex][Wallet][x]; 
        }
        if(MaxAmount < UserPurchasedAmount) { MaxAmount = UserPurchasedAmount; }
        PurchasableAmount = MaxAmount - UserPurchasedAmount;
        (Verified, Priority) = ViewBrightListStatus(SaleIndex, Wallet, ProofEligibility);
        if(Verified) { VerifiedAmount = __VerifyAmount(Wallet, MaxAmount, SaleParams[SaleIndex]._RootsAmounts[Priority], ProofAmount); }
        return (
            _UserSaleInformation (
                UserInfo[SaleIndex][Wallet]._UserOrderIndexes,                                // The User's Order Indexes
                PriorityPurchaseAmounts,                                                      // The User's Purchase Amounts Corresponding To Priority 
                UserPurchasedAmount,                                                          // The User's Total Purchase Amount For `SaleIndex`
                PurchasableAmount,                                                            // The User's Purchasable Amount                          
                UserInfo[SaleIndex][Wallet]._ClaimIndex,                                      // The User's Claim Index
                Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold, // The Remaining Amount Available For Sale
                CurrentPrice,                                                                 // The Current Price Of A Sale
                Priority,                                                                     // The Priority The User Is Eligible For
                Credit,                                                                       // The User's Pending Credit Available To Use Towards Next Purchase
                Verified,                                                                     // If The User Is Eligible For BrightList
                VerifiedAmount,                                                               // If The User Is Eligible For The MaxAmount
                ActiveRespend,                                                                // If ActiveRespend Credit Is Active
                Active                                                                        // If The Sale Is Active
            )
        );
    }
    
    /**
     * @dev Batch Returns Multiple Sale Informations For A User
     * @param SaleIndexes        | The Sale Indexes
     * @param Wallet             | The Currently Connected Wallet
     * @param MaxAmounts         | The Max Amount Of Tokens The User Can Purchase
     * @param Vault              | The Vault Address
     * @param ProofEligibilities | The Proof For The BrightList
     * @param ProofAmounts       | The Proof For The MaxAmount
     * note: The Array Lengths Must Match
     */
    function ViewWalletSaleInformations (
        uint[] calldata SaleIndexes, 
        address Wallet, 
        uint[] calldata MaxAmounts, 
        address Vault, 
        bytes32[][] calldata ProofEligibilities, 
        bytes32[][] calldata ProofAmounts
    ) public view returns(_UserSaleInformation[] memory) {
        require(
            SaleIndexes.length == MaxAmounts.length 
            && 
            MaxAmounts.length == ProofEligibilities.length 
            && 
            ProofEligibilities.length == ProofAmounts.length, 
            "DutchMarketplace: Array Lengths Must Match"
        );
        _UserSaleInformation[] memory _UserSaleInformations = new _UserSaleInformation[](SaleIndexes.length);
        for(uint x; x < SaleIndexes.length; x++)
        {
            _UserSaleInformations[x] = ViewWalletSaleInformation (
                SaleIndexes[x],
                Wallet,
                MaxAmounts[x],
                Vault,
                ProofEligibilities[x],
                ProofAmounts[x]
            );
        }
        return _UserSaleInformations;
    }

    /**
     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive
     * @param SaleIndex | The Sale Index To Edit
     */
    function ViewOrders(uint SaleIndex) external view returns (Order[] memory) { return Orders[SaleIndex]; }

    /**
     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive
     * @param SaleIndex     | The Sale Index To Edit
     * @param StartingIndex | The Starting Index
     * @param EndingIndex   | The Ending Index
     */
    function ViewOrdersInRange(uint SaleIndex, uint StartingIndex, uint EndingIndex) external view returns (Order[] memory) 
    { 
        uint Range = EndingIndex - StartingIndex;
        Order[] memory _Orders = new Order[](Range);
        for(uint x; x < Range; x++) { _Orders[x] = Orders[SaleIndex][StartingIndex+x]; }
        return _Orders; 
    }

    /**
     * @dev Returns A [][] Of All Orders On Multiple SaleIndexes Within A Range `StartingIndex` & `EndingIndex` Inclusive
     * @param SaleIndexes   | The Sale Indexes
     * @param StartingIndex | The Starting Index
     * @param EndingIndex   | The Ending Index
     */
    function ViewAllOrders(uint[] calldata SaleIndexes, uint StartingIndex, uint EndingIndex) external view returns (Order[][] memory)
    {
        Order[][] memory __Orders = new Order[][](EndingIndex-StartingIndex);
        for(uint SaleIndex; SaleIndex <= SaleIndexes.length; SaleIndex++) { __Orders[SaleIndex] = Orders[SaleIndex]; }
        return __Orders;
    }

    /**
     * @dev Returns Sale Index By NFT Contract Address
     * @param NFT | The NFT Address
     */
    function ViewSaleIndexByNFTAddress(address NFT) public view returns (uint)
    {
        uint SaleIndex = NFTAddressToSaleIndex[NFT];
        if(SaleIndex != 0) { return SaleIndex; }
        return 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; // type(uint).max
    }

    /**
     * @dev Returns an [] Of Sale States
     * @param SaleIndexes | The Sale Indexes
     */
    function ViewSaleStates(uint[] calldata SaleIndexes) public view returns (Sale[] memory, Info[] memory)
    {
        Sale[] memory _Sales = new Sale[](SaleIndexes.length);
        Info[] memory _Infos = new Info[](SaleIndexes.length);
        bool Active;
        for(uint x; x < SaleIndexes.length; x++) 
        { 
            Active = SalesInternal[SaleIndexes[x]]._ActivePublic || SalesInternal[SaleIndexes[x]]._ActiveBrightList;
            _Sales[x] = Sales[SaleIndexes[x]]; 
            _Infos[x] = Info(
                __ViewCurrentPrice(SaleIndexes[x]),
                Sales[SaleIndexes[x]]._MaximumAvailableForSale,
                Sales[SaleIndexes[x]]._MaximumAvailableForSale - SaleState[SaleIndexes[x]]._AmountSold,
                Active
            );
        }
        return (_Sales, _Infos);
    }

    /**
     * @dev Returns The Current Pending Credit / Rebate Of A User (With No Discount) Until The Sale Has Concluded.
     * @param SaleIndex | The Sale Index To Edit
     * @param Wallet    | The Wallet Address
     * @return TotalCredit | The Total Pending Credit
     * note: When The Final Clearing Price Is Seeded, This Function Switches To Show The User's Final Rebate (With Discounts If Eligible)
     */
    function ViewPendingCredit(uint SaleIndex, address Wallet) public view returns (uint)
    {
        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);
        uint TotalCredit;
        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice;
        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes;
        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;
        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)
        {
            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];
            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) 
            {
                TotalCredit += _Order._PurchaseValue - 
                (
                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)
                    * 
                    _Order._PurchaseAmount
                );
            }
            else if (!_Order._Claimed) { TotalCredit += (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice)); }
        }
        return TotalCredit;
    }

    /**
     * @dev Returns An [] Of Internal Sale States
     * @param SaleIndexes | The Sale Indexes
     * @return InternalSales | The Internal Sales
     */
    function ViewInternalSaleStates(uint[] calldata SaleIndexes) public view returns (InternalSale[] memory)
    {
        InternalSale[] memory _InternalSales = new InternalSale[](SaleIndexes.length);
        for(uint x; x < SaleIndexes.length; x++) { _InternalSales[x] = SalesInternal[SaleIndexes[x]]; }
        return _InternalSales;
    }

    /**
     * @dev Returns All Order Information Including Addresses And Corresponding Refund Amounts
     * @param SaleIndex | The Sale Index To Edit
     * @return Addresses | The Addresses
     * @return Refunds | The Refunds
     */
    function ViewAllOrderRefunds(uint SaleIndex) public view returns (address[] memory, uint[] memory)
    {
        address[] memory Addresses = new address[](SaleState[SaleIndex]._UniqueSales);
        uint[] memory Refunds = new uint[](SaleState[SaleIndex]._UniqueSales);
        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;
        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);
        Order memory _Order;
        for(uint OrderIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)
        {
            _Order = Orders[SaleIndex][OrderIndex];
            if(_Order._BrightListPurchase)
            {
                Refunds[OrderIndex] = _Order._PurchaseValue - (
                    ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100) * _Order._PurchaseAmount
                );
            }
            else { Refunds[OrderIndex] = _Order._PurchaseValue - (CurrentPrice * _Order._PurchaseAmount); }
            Addresses[OrderIndex] = _Order._Purchaser;
        }
        return(Addresses, Refunds);
    }

    /**
     * @dev Returns A User's Sale Stats Including Total Amount Purchased, Total Amount Spent, And Total Amount Rebated
     * @param SaleIndex | The Sale Index To Edit
     * @param Wallet    | The Wallet Address
     * @return NUM_ORDERS | The Total Number Of Orders
     * @return NUM_PURCHASED | The Total Amount Purchased
     * @return FINAL_ETH_SPENT | The Total Amount Spent
     * @return FINAL_ETH_REBATE | The Total Amount Rebated
     * note: This Function Will Only Return Wallet Stats For A Sale That Has Concluded
     * note: `NUM_ORDERS` Is The Final Cumulative Order Count Of `Wallet`
     * note: `NUM_PURCHASED` Is The Total Number Of NFTs Purchased At `SaleIndex` By `Wallet`
     * note: `FINAL_ETH_SPENT` Is The Cumulative Expended ETH Value From `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction
     * note: `FINAL_ETH_REBATE` Is The Cumulative Unspent ETH That Is Rebated To `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction
     * note: ETH Values Are Returned In WEI
     * note: This Function Was A Request From The Keith Who Loves Vapes
     */
    function ViewSaleStats(uint SaleIndex, address Wallet) public view returns (uint NUM_ORDERS, uint NUM_PURCHASED, uint FINAL_ETH_SPENT, uint FINAL_ETH_REBATE)
    {
        require(SaleState[SaleIndex]._FinalClearingPrice > 0, "Sale Not Concluded");
        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);
        uint FinalRebate;
        uint Spent;
        uint NumPurchased;
        uint OrderRebate;
        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice; // Retrieves The Final Clearing Price
        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes; // Retrieves The User's Purchase Order Indexes
        uint NumOrders = _UserOrderIndexes.length;
        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;
        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)
        {
            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];
            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) // brightlist priority discount
            {
                OrderRebate = _Order._PurchaseValue - 
                (
                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)
                    * 
                    _Order._PurchaseAmount
                );
            }
            else { OrderRebate = (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice));  } // no discount
            FinalRebate += OrderRebate;
            Spent += (_Order._PurchaseValue - OrderRebate);
            NumPurchased += _Order._PurchaseAmount;
        }
        return (NumOrders, NumPurchased, Spent, FinalRebate);
    }

    /**
     * @dev Returns All State Parameters Of A Sale
     * @param SaleIndex            | The Sale Index To Edit
     * @return Sale                | The Sale Struct
     * @return InternalSale        | The Internal Sale Struct
     * @return MiscSale            | The Misc Sale Struct
     * @return SaleParam           | The Sale Param Struct
     * @return Price               | The Current Price
     */
    function ViewAllSaleInformation(uint SaleIndex) public view returns (Sale memory, InternalSale memory, MiscSale memory, SaleParam memory, uint Price)
    {
        return ( Sales[SaleIndex], SalesInternal[SaleIndex], SaleState[SaleIndex], SaleParams[SaleIndex], __ViewCurrentPrice(SaleIndex));
    }

    /**
     * @dev Returns If User Is On BrightList
     * @param SaleIndex | The Sale Index To Edit
     * @param Recipient | The Recipient
     * @param Proof     | The Proof
     * @return Verified | If The User Is On BrightList
     * @return Priority | The Priority Index
     * note: Returns BrightList Status & Best Priority Index
     */
    function ViewBrightListStatus(uint SaleIndex, address Recipient, bytes32[] calldata Proof) public view returns (bool, uint)
    {
        bool Verified;
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        for(uint PriorityIndex; PriorityIndex < SaleParams[SaleIndex]._Roots.length; PriorityIndex++) 
        { 
            Verified = MerkleProof.verify(Proof, SaleParams[SaleIndex]._Roots[PriorityIndex], Leaf); 
            if(Verified) { return (true, PriorityIndex); }
        }
        return (false, _DEFAULT_PRIORITY);
    }

    /**
     * @dev Returns The Amount Of Seconds Until The Auction Reaches It's Resting Price
     * @param SaleIndex | The Sale Index
     * @return SecondsUntilResting | The Amount Of Seconds Until The Auction Reaches It's Resting Price
     */
    function ViewSecondsUntilResting(uint SaleIndex) public view returns (uint SecondsUntilResting) 
    {
        if(block.timestamp <= Sales[SaleIndex]._StartingBlockUnixTimestamp) { return 0; } // Sale Not Started
        uint SecondsElapsed = block.timestamp - Sales[SaleIndex]._StartingBlockUnixTimestamp;
        uint SecondsBetweenPriceDecay = Sales[SaleIndex]._SecondsBetweenPriceDecay;
        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);
        uint PriceEnd = Sales[SaleIndex]._PriceEnd;
        if(CurrentPrice <= PriceEnd) { return 0; }
        return (
            SecondsBetweenPriceDecay 
            - 
            (SecondsElapsed % SecondsBetweenPriceDecay)) 
            + 
            (SecondsBetweenPriceDecay * 
            ((CurrentPrice - PriceEnd) * 2 / (CurrentPrice - (CurrentPrice >> 1)))
        );
    }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid
     * @param _Wallet | The Wallet Address
     * @param _Amount | The Amount
     * @param _Root   | The Merkle Root
     * @param _Proof  | The Merkle Proof
     * @return IsValid   | If The Amount Is Valid
     * note: Verifies The Maximum Amount Of NFTs A User Can Purchase
     */
    function __VerifyAmount(address _Wallet, uint _Amount, bytes32 _Root, bytes32[] calldata _Proof) internal pure returns (bool IsValid)
    {
        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));
        return MerkleProof.verify(_Proof, _Root, _Leaf);
    }

    /**
     * @dev Returns Current Dutch Price For Sale Index
     * @param SaleIndex | The Sale Index To Edit
     */
    function __ViewCurrentPrice(uint SaleIndex) internal view returns (uint Price)
    {
        if(block.timestamp <= Sales[SaleIndex]._StartingBlockUnixTimestamp) { return Sales[SaleIndex]._PriceStart; }  // Sale Not Started
        if(SaleState[SaleIndex]._FinalClearingPrice > 0) { return SaleState[SaleIndex]._FinalClearingPrice; } // Sale Finished
        uint CurrentPrice = Sales[SaleIndex]._PriceStart; // Initiates Current Price
        uint SecondsElapsed = block.timestamp - Sales[SaleIndex]._StartingBlockUnixTimestamp; // Unix Seconds Elapsed At Current Query Timestamp
        CurrentPrice >>= SecondsElapsed / Sales[SaleIndex]._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % Sales[SaleIndex]._SecondsBetweenPriceDecay)) / Sales[SaleIndex]._SecondsBetweenPriceDecay / 2;
        if(CurrentPrice <= Sales[SaleIndex]._PriceEnd) { return Sales[SaleIndex]._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Ends A Sale
     * @param SaleIndex | The Sale Index To Edit
     */
    function __EndSale(uint SaleIndex) internal 
    { 
        SalesInternal[SaleIndex]._ActivePublic = false; 
        SalesInternal[SaleIndex]._ActiveBrightList = false;
    }

    /**
     * @dev Refunds `Recipient` ETH Amount `Value`
     * @param Recipient | The Recipient
     * @param Value     | The Value
     */
    function __Refund(address Recipient, uint Value) internal
    {
        (bool Confirmed,) = Recipient.call{value: Value}(""); 
        require(Confirmed, "DutchMarketplace: Refund Failed");
        emit Refunded(Value);
    }

    /**
     * @dev Uses ETH Unspent By A User's Previous Purchase Orders Towards A New Purchase Order
     * @param SaleIndex     | The Sale Index To Edit
     * @param CurrentPrice  | The Current Price
     * @param PurchaseValue | The Purchase Value
     * @param Recipient     | The Recipient
     * @return TotalCredit  | The Total Credit Available
     */
    function __ActiveRespend(uint SaleIndex, uint CurrentPrice, uint PurchaseValue, address Recipient) internal returns (uint TotalCredit)
    {
        uint PotentialCredit;
        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Recipient]._UserOrderIndexes;
        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)
        {
            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];
            require(Recipient == _Order._Purchaser, "DutchMarketplace: Invalid State");
            if(TotalCredit == PurchaseValue) { return TotalCredit; } // Returns Sufficient Credit For Entire Purchase Order
            else if (!_Order._Claimed)
            {
                PotentialCredit = _Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice); 
                if(PotentialCredit + TotalCredit > PurchaseValue) { PotentialCredit = PurchaseValue - TotalCredit; } // Only Pull As Much Credit As Needed
                Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]]._PurchaseValue = _Order._PurchaseValue - PotentialCredit;
                TotalCredit += PotentialCredit;
            }
        }
        return TotalCredit; // Returns The Total Amount Of Credit Available
    }
}

/**
 * @dev Interface For ERC20
 */
interface IERC20 { function approve(address From, address To, uint Amount) external; }

/**
 * @dev Interface For ERC721
 */
interface IERC721 
{ 
    /**
     * @dev MintPass Factory Direct Mint
     */
    function _MintToFactory(address To, uint Amount) external;

    /**
     * @dev MintPass Factory Mint Pack Direct Mint
     */
    function _MintToFactoryPack(address To, uint Amount) external;

    /**
     * @dev MintPass Factory Mint Pack Direct Mint For Bespoke Mint Passes
     */
    function _MintToBespoke(address To, uint Amount) external;

    /**
     * @dev Standard ERC721 Transfer
     */
    function transferFrom(address From, address To, uint TokenID) external; 

    /**
     * @dev ArtBlocks purchaseTo() Function
     */
    function purchaseTo(address _to, uint _projectID) external payable returns (uint _tokenId);
}

/**
 * @dev Interface For delegate.cash Delegation Registry
 */
interface IDelegationRegistry
{
    /**
     * @dev Checks If A Vault Has Delegated To The Delegate
     */
    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);
}